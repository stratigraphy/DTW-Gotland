---
title: "Semi-automated correlation of Silurian well-logs across Gotland, Sweden, using Dynamic Time Warping with Barycenter Averaging"
title-block-banner: "darkturquoise"
author: 
  - "Michiel Arts^1^"
  - "Daniel Sopher^2^" 
  - "Mikael Calner^3^"
  - "Mikael Erlström^3^" 
  - "Rohit Samant^4^" 
  - "Bradley Cramer^5^" 
  - "Anne-Christine Da Silva^1^"
  - " " 
  - " " 
  - "1 - SEDICLIM lab, Department of Geology, University of Liege, Belgium (michiel.arts@uliege.be)" 
  - "2.- Geological Survey of Sweden, Dragarbrunnsgatan 77, 75319, Uppsala, Sweden"
  - "3.- Department of Geology, Lund University, Sölvegatan 12, SE-223 62 Lund, Sweden"
  - "4.- Institute of Geology and Palaeontology, University of Münster, 48149, Münster, Germany"
  - "5.- Department of Earth and Environmental Sciences, University of Iowa, Iowa City, Iowa, USA "

date: Nov-2025
bibliography: D:/Phd/documents/DTW/DTW.bib
csl: geology.csl
format:
  html:
    embed-resources: TRUE
    toc: true
    toc-depth: 3
    code-fold: true         # code blocks can be toggled
    css: styles.css
    execute:
      echo: true            # show code in HTML, but foldable
      message: false
      warning: false
      cache: true
  docx:
    code-blocks: false       # hide all code in Word
    execute:
      echo: false            # ensure code is hidden
      message: false
      warning: false
      cache: true
execute:
  cache: true
editor: 
  markdown: 
    wrap: sentence
---

```{r setting for the study}
#| echo: FALSE
#| results: hide
# Detect output format

renderstyle_echo <- if (knitr::is_html_output()) TRUE else FALSE

# Set chunk options dynamically
knitr::opts_chunk$set(
  echo = renderstyle_echo)

show_callout <- knitr::is_html_output()
```


# ABSTRACT 
Studies of the Silurian sequence on Gotland have significantly advanced our understanding of Silurian climate dynamics, with much of the research focusing on small outcrops and short cores. Gotland has an extensive network of abandoned oil and gas wells. Most of these include gamma-ray well logs, which have not yet been fully utilised for their stratigraphic value. While the Ordovician succession has been successfully correlated using these well logs, the correlation for the Silurian succession has yet to be fully realised. The present study addresses some limitations of Dynamic Time Warping (DTW) correlations by combining DTW with Barycenter Averaging (DBA). The workflow advances existing DTW/DBA approaches by integrating geologically informed pre-stretching with iterative DBA reference-curve construction; together, this enabled the drawing of geologically coherent and internally consistent correlations across multiple wells. The new workflow enabled semi-automated correlation of Silurian well logs over a ~60 km transect. The resulting correlations refine Gotland’s Silurian subsurface architecture by resolving fifteen stratigraphic units, identifying laterally persistent gamma-ray motifs linked to δ¹³C excursions, and revealing local unconformities. This correlation framework extends surface-mapped stratigraphy and biogeochemical events into the subsurface, clarifying how Silurian δ¹³C excursions are expressed in well-log motifs on a basinal scale. Using Gotland as a case study, our results demonstrate how a DTW/DBA-based workflow can integrate subsurface well-log data to produce coherent stratigraphic correlations, offering a broadly applicable and readily transferable approach for use in other basins. 

# INTRODUCTION

The goal of this paper is twofold. First, introduce a new quasi-automated workflow for well-log correlation that leverages the DTW algorithm with Barycenter Averaging (DBA). Secondly, to apply and test this workflow on a set of gamma-ray well logs from Gotland, Sweden, to improve the well-to-well correlations, thereby enabling a more detailed understanding of the subsurface framework of the Silurian succession beneath Gotland.
Geophysical well logs are an indispensable tool for geoscience, enabling the understanding of subsurface stratigraphy, lithological changes, and depositional facies. Closely spaced well logs enable higher-resolution reconstruction of sedimentary successions than is achievable with seismic reflection methods. Well-log-based correlations are often performed manually, a time-intensive and subjective process. This limitation highlights the need for automated workflows to efficiently analyse large datasets. Dynamic time warping (DTW) has emerged as a powerful algorithm for this purpose, offering efficient correlation across very different records, in complex stratigraphic setting [@linemanWellWellLog1987; @fangComputeraidedWellLog1992; @zorasterCurveAlignmentWelltoWell2004; @hladilDynamicTimewarpingApproach2010; @lallierRelevanceStochasticStratigraphic2012; @lallierUncertaintyAssessmentStratigraphic2016; @wheelerAutomaticSimultaneousCorrelation2015; @wuIncrementalCorrelationMultiple2018; @grantRapidReservoirModeling2018; @bavilleComputerassistedStochasticMultiwell2022; @sylvesterAutomatedMultiwellStratigraphic2023; @nieminskiTurbiditeCorrelationPaleoseismology2024;@hagenDynamicTimeWarping2020; @hagenDynamicTimeWarping2023; @HAGEN2024112321].

By aligning time-equivalent strata across diverse logs, DTW can streamline well-log correlation and improve the resolution of subsurface interpretations. A major drawback of applying DTW to multiple records it that it might produce inconsistent correlations when extended across multiple wells, also known as the DTW open-loop problem [ @sylvesterAutomatedMultiwellStratigraphic2023]. To address this, three general strategies have emerged for correlating stratigraphic records using DTW. The first approach propagates stratigraphic surfaces from a single reference curve [@wuIncrementalCorrelationMultiple2018; @hayLibraryEarlyCambrian2019; @hagenDynamicTimeWarping2020; @hagenDynamicTimeWarping2023; @HAGEN2024112321]. This method depends heavily on the accuracy of the reference curve, as any errors are propagated throughout the correlation network. The second strategy performs pairwise correlations between records, followed by a global realignment to ensure consistency [@wheelerSimultaneousCorrelationMultiple2014; @sylvesterAutomatedMultiwellStratigraphic2023; @nieminskiTurbiditeCorrelationPaleoseismology2024].
A drawback of this technique is that local mismatches in pairwise correlations can propagate errors during global realignment, leading to geologically unrealistic outcomes. This approach can also be computationally intensive, depending on the algorithm used. The third method iteratively refines correlations to converge on a consistent solution [@lallierUncertaintyAssessmentStratigraphic2016; @edwardsUncertaintyManagementStratigraphic2018].
Although this improves global consistency, it may converge on locally optimal but unrealistic results, particularly without stratigraphic constraints such as biozonations. Like the second approach, it can also be computationally demanding.

To overcome some of the limitations of existing DTW-based methods, we introduce a workflow that enhances traditional DTW techniques with two key innovations. This includes the use of relative stratigraphic depth (re)scaling before implementing the DTW algorithm, as well as the creation of an iterative reference curve generation using DTW with Barycenter Averaging (DBA). The iterative approach enables the reference curve to evolve dynamically based on an ensemble of input well logs, thereby reducing the bias that would arise if one relied on a single reference lo

The workflow is applied to a dataset of gamma-ray well logs from Gotland, Sweden. The island has long been recognised for its Silurian succession, including major biogeochemical events such as the Ireviken, Mulde, Linde, and Lau events [@jeppssonRecognitionProbableSecundo1996; @jeppssonSilurianMuldeEvent2002; @calnerSilurianGotlandPart2004a; @calnerSilurianGotlandPart2004; @calnerEvidenceRapidEnvironmental2006; @erikssonSequenceStratigraphicalModel2008; @vandenbrouckeReconstructingEnvironmentalConditions2013; @biebesheimerAsynchronousD13CcarbD13Corg2021; @hartkeDecouplingD13CcarbD13Corg2021; @erlstromBerggrundenPaSudret2022].
 Although outcrops and shallow cores from Gotland have yielded valuable insights into Silurian climate and biosphere dynamics, their stratigraphic thickness is often limited. Indeed, among the Silurian biogeochemical events, only the formations encompassing the Lau Event have been extensively mapped in the shallow subsurface using well logs [@erikssonSequenceStratigraphicalModel2008; @erlstromBerggrundenPaSudret2022].
Two of the key wells in this study are the Altajme core/well and the St. Sutarve 2018 well, available in their original high-resolution digital form, unlike the rest of the dataset, which consists of digitised records. The Altajme core/well offers one of the highest-resolution δ13Ccarb records of the Silurian [@biebesheimerAsynchronousD13CcarbD13Corg2021; @hartkeDecouplingD13CcarbD13Corg2021; @stolfusExpansionReducingMarine2023], encompassing both the Ireviken and Mulde events. Integrating this core with gamma ray logs from Gotland enables a regional contextualization. The St. Sutarve-2018 well is central in the geological framework of the subsurface of Southern Gotland [@erlstromBerggrundenPaSudret2022].
Placing this well within a broader regional context will enable a more refined understanding of the geological evolution of Gotland. The implemented workflow will improve stratigraphic correlations across a transect of  ~60 kilometres, linking surface and subsurface data, but also establishes a new avenue for the application of Dynamic Time Warping in stratigraphic studies.

# GEOLOGICAL SETTING

The Silurian succession on Gotland was deposited in the Baltic Basin, an intracratonic basin on the palaeocontinent Baltica. During the Silurian, Gotland was located on the northwest flank of the basin, where the water depth increased to the south-east [@baarliSilurianStratigraphyPaleogeography2003].
 The thickness of the succession increased from circa 250 m in the north to circa 500 m in the south of Gotland, as the basin has a gentle dip of 0.2-0.4 degrees to the southeast.  Baltica was located ~10–20° south of the equator during the Silurian, and deposition occurred in a tropical to subtropical setting. The succession is typified by approximately 100 carbonate platforms that prograded from the northeast to southwest during the Silurian [@bjerkeusLateSilurianReef2001; @flodenSilurianReefalSuccession2001; @tuulingSilurianReefsSaaremaa2013].
These platforms fingers out into in deeper marine depositional settings to the S-SE.   The resulting stratigraphy consists of alternating shale or marl and reefal limestone, forming a south-eastward-prograding sequence [@jeppssonRecognitionProbableSecundo1996; @calnerSilurianGotlandPart2004a; @calnerSilurianGotlandPart2004; @calnerSilurianCarbonatePlatforms2005; @calnerShorelineDeepBasin2006; @jeppssonLatestLlandoveryLatest2006].
Due to erosion and the regional dip, progressively younger strata are exposed toward the southeast. 

Within individual units, shallow-water facies such as reefal carbonates dominate the northwest, transitioning to deeper-water shales and marls in the southeast.  A long-term shallowing trend during the Silurian led to the gradual south-eastward progradation of reefal facies, with shallow reef deposits reaching southeastern Gotland by the Ludfordian [@bjerkeusLateSilurianReef2001; @flodenSilurianReefalSuccession2001; @tuulingLlandoverylowermostWenlockSequence2009].

The Silurian strata of Gotland, Sweden, provide an exceptional record of biotic, geochemical, and lithological changes during the Silurian, including the Ireviken, the Mulde, Linde and Lau events [@aldridgeEarlySilurianOceanic1993; @jeppssonLatestLlandoveryLatest2006; @jeppssonWenlockSilurianOceanic1995; @jeppssonLudlowLateSilurian2000; @calnerSilurianGotlandPart2004; @calnerSilurianGotlandPart2004; @calnerSilurianResearchCrossroads2006; @vandenbrouckeReconstructingEnvironmentalConditions2013; @younesFirstContinuousD13C2017; @bowmanLinkingProgressiveExpansion2019; @biebesheimerAsynchronousD13CcarbD13Corg2021; @hartkeDecouplingD13CcarbD13Corg2021; @stolfusExpansionReducingMarine2023; @claussenBenthicResponseStrong2024].
T. These events represent major perturbations to the Earth's climate system, characterised by extinction episodes, shifts in carbon isotope signatures, and substantial changes in marine ecosystems and depositional environments.

The Ireviken Event is the oldest Silurian event recorded on Gotland and spans the Llandovery-Wenlock boundary interval, and is represented in the Lower Visby to Hangvar. The Ireviken Event is associated with a major extinction event and a positive δ13C excursion [@jeppssonLithologicalConodontDistributional1987; @melchinSilurianPeriod2005; @melchinSilurianPeriod2020; @cramerPaleobiogeographyHighresolutionStratigraphy2010; @roseRecordsCarbonSulfur2019].
The Mulde Event, occurring during the Homerian Stage (\~428 Ma),, is preserved in the Fröjel to Klinteberg formations and linked to a minor extinction and a positive δ13C excursion [@samtlebenDevelopmentFaciesOisotopes2000; @calnerCarbonatePlatformEvolution2003; @calnerShorelineDeepBasin2006; @jeppssonLatestLlandoveryLatest2006].
The Linde Event took place in the early Ludfordian and is associated with a minor extinction and a tiny  δ13C  excursion [@jeppssonLudlowLateSilurian2000; @claussenBenthicResponseStrong2024].
The Lau Event took place in the late Ludfordian and is associated with a major extinction event and one of the largest δ13C excursions of the entire Phanerozoic [@calnerShorelineDeepBasin2006; @calnerSilurianGlobalEvents2008; @erikssonSequenceStratigraphicalModel2008; @younesFirstContinuousD13C2017; @frydaMidLudfordianLateSilurian2021].
The Lau Event is recorded in the Botvide member of the När Formation and the Eke and Burgsvik formations [@jeppssonSilurianOceanicEvents1998; @calnerLateSilurianExtinction2005; @erikssonSequenceStratigraphicalModel2008; @erlstromBerggrundenPaSudret2022].

```{r chunk-98}
#| message: false
#| warning: false
#| echo: true
#| fig.cap: "Figure 1a.  Location of the wells used in this study. The Geological map of Gotland (modified after Manten, (1971) and Calner et al. (2004a)). The locations of the forty wells included in this study are marked as black dots."



 #Plot some maps ####
well_tops_rotated <- read.csv("https://raw.githubusercontent.com/stratigraphy/DTW-Gotland/main/well_tops_rotated.csv")

well_tops_rotated_3  <- well_tops_rotated
GROTLLINGBO_2 <- c(1660138,6335746,"Grotlingbo_2",rep(1,6))
GROTLLINGBO_1 <- c(1660000,6335550,"Grotlingbo_1",rep(1,6))
GROTLLINGBO <- rbind(GROTLLINGBO_1,GROTLLINGBO_2)
#GROTLLINGBO <- as.data.frame(GROTLLINGBO)
colnames(GROTLLINGBO) <- colnames(well_tops_rotated_3)
well_tops_rotated_3 <- rbind(well_tops_rotated_3,GROTLLINGBO)
well_tops_rotated_3[,1] <- as.numeric(well_tops_rotated_3[,1])
well_tops_rotated_3[,2] <- as.numeric(well_tops_rotated_3[,2])

exclude_wells <- c(
  "Skaggs_1",
  "Sanda_1",
  "Rings_1",
  "Grotlingbo_2",
  "Grotlingbo_1",
  "Grotlingbo_2_Res"
)

# Remove excluded wells
well_tops_rotated_3 <- well_tops_rotated_3[!well_tops_rotated_3$Well %in% exclude_wells, ]

#load a shapefile
#shapename <- st_read('D:/Phd/documents/Altajme/DTW_paper/well_logs/SI_4_logs_used/maps')
#local_path <- "DTW_Gotland_Local/SI_4_logs_used/maps/gotland_wells.shp" # Replace 'gotland_wells.shp' with the actual shapefile name

# 3. READ THE SHAPEFILE
#shapename <- st_read(local_path)


library(sf)
library(ggrepel)
library(ggspatial)
library(rnaturalearth)

# 1. Define the necessary files and their base URL
base_url <- "https://raw.githubusercontent.com/stratigraphy/DTW-Gotland/main/SI_4_logs_used/maps/gotland_geology_2"
extensions <- c(".shp", ".shx", ".dbf", ".prj", ".cpg")

# 2. Create a temporary directory to save the files
temp_dir <- tempdir()
local_shp_path <- file.path(temp_dir, "gotland_geology_2.shp")

# 3. Download each component file
for (ext in extensions) {
  file_url <- paste0(base_url, ext)
  local_file_path <- file.path(temp_dir, paste0("gotland_geology_2", ext))
  
  # Use download.file to fetch the raw file content
  # mode="wb" (write binary) is crucial for non-text files like .shp and .dbf
  download.file(url = file_url, destfile = local_file_path, mode = "wb")
}

# 4. Read the shapefile from the local temporary directory
# st_read now sees all related files locally, which avoids the GDAL/HTTPS issues.

shapename <- st_read(local_shp_path,quiet=TRUE)

Visby <- shapename[shapename$id == 1, ]
Hogklint <- shapename[shapename$id == 2, ]
Tofta <- shapename[shapename$id == 3, ]
Hangvar <- shapename[shapename$id == 4, ]
Slite <- shapename[shapename$id == 5, ]
Frojel <- shapename[shapename$id == 6, ]
Halla <- shapename[shapename$id == 7, ]
L_Hemse <- shapename[shapename$id == 8, ]
Etelheim <- shapename[shapename$id == 9, ]
Klinteberg <- shapename[shapename$id == 10, ]
Nar <- shapename[shapename$id == 11, ]
Eke <- shapename[shapename$id == 12, ]
Brugsvik <- shapename[shapename$id == 13, ]
Hamra <- shapename[shapename$id == 14, ]
Visby$id <- c("Visby Fm")

#plot the geological map of Gotland

pl <- ggplot() +
  geom_sf(data = shapename) +
  coord_sf(default_crs = sf::st_crs(x = 2400), clip = "off")
pl + geom_sf(data = Visby,
             fill  = rgb(195, 121, 170, 255, maxColorValue = 255)) +
  geom_sf(data = Hogklint,
          fill  = rgb(63, 100, 168, 255, maxColorValue = 255)) +
  geom_sf(data = Tofta,
          fill  = rgb(71, 165, 201, 255, maxColorValue = 255)) +
  geom_sf(data = Hangvar, fill  = "#076766ff") +
  geom_sf(data = Slite, fill  = "#1d9b38ff") +
  geom_sf(data = Frojel, fill  = "#999999ff") +
  geom_sf(data = Halla, fill  = "#976818ff") +
  geom_sf(data = L_Hemse, fill  = "#976818ff") +
  geom_sf(data = Etelheim, fill  = "#8f8d54ff") +
  geom_sf(data = Klinteberg, fill  = "#ccde92ff") +
  geom_sf(data = Nar, fill  = "#cb9807ff") +
  geom_sf(data = Eke, fill  = "#f4981dff") +
  geom_sf(data = Brugsvik, fill  = "#f1e513ff") +
  geom_sf(data = Hamra, fill  = "#fdcc68ff") +
  geom_point(aes(x = well_tops_rotated_3$X, y = well_tops_rotated_3$Y))+  
  geom_label_repel(
    aes(x = well_tops_rotated_3[, 1], y = well_tops_rotated_3[, 2], label = well_tops_rotated_3[, 3]),
    box.padding   = 0.2,
    point.padding = 0.2,
    size = 1,
    max.overlaps = getOption("ggrepel.max.overlaps", default = 50),
    segment.color = 'red',
    segment.size = 0.1,   # ensure segment line is visible
    segment.alpha = 1     # ensure it's not transparent
  ) + annotation_scale(location = "tl") +
  annotation_north_arrow(location = "br",
                         which_north = "true",
                         style = north_arrow_minimal())
```

```{r chunk-98.1}
#| message: false
#| warning: false
#| echo: true
#| fig.cap: "Figure 1B. zoomout map of the study area"



#plot regional overview map

europe <- ne_countries(
  continent = "Europe",
  scale = 'medium',
  type = 'map_units',
  returnclass = 'sf'
)

# your_map <- ggplot(europe) +
#   geom_sf() +
#   xlim(c(15, 30)) +
#   ylim(c(50, 62)) +
#   theme_linedraw() + geom_rect(
#     aes(
#       xmin = 17.6,
#       xmax = 19.5,
#       ymin = 56.8,
#       ymax = 58.1
#     ),
#     fill = "NA",
#     col = "black"
#   ) + annotation_scale(location = "bl") +
#   annotation_north_arrow(location = "tl",
#                          which_north = "true",
#                          style = north_arrow_minimal())
# 
# your_map


your_map <- ggplot(europe) +
  geom_sf() +
  xlim(c(10, 30)) +
  ylim(c(52, 65)) +
  theme_linedraw() + geom_rect(
    aes(
      xmin = 17.6,
      xmax = 19.5,
      ymin = 56.8,
      ymax = 58.1
    ),
    fill = "NA",
    col = "black"
  ) + annotation_scale(location = "bl") +
  annotation_north_arrow(location = "tl",
                         which_north = "true",
                         style = north_arrow_minimal())

your_map


```

# MATERIALS AND METHODS

This study utilises a total of thirty-eight gamma-ray well logs from Gotland (see Figure 1 and SI.1), several of which have been published [@sopherStructureStratigraphySedimentary2016; @erlstromGeophysicalWellLogmotifs2019; @levendalInvestigationOrdovicianCarbonate2019; @erlstromBerggrundenPaSudret2022].The Altajme and St. Sutarve 2018 wells are available in original high-resolution digital form, while the rest belong to the legacy Oljeprospektering AB  (OPAB) dataset managed by the Swedish Geological Survey (SGU), originally acquired as analogue paper logs by Oljeprospektering AB between 1960 and 1990; SGU has since digitised a subset of these. Missing or incomplete logs were manually digitised for this study using the  Log-Evolve™ software (see SI.1).
The wells sampled in this study represent more distal shelfal successions rather than shallow reefal carbonates (see Figure 1 and geological setting), making them especially suitable for dynamic time warping (DTW) since they offer greater continuity and completeness.

The wells sampled in this study represent more distal shelfal successions rather than shallow reefal carbonates (see Figure 1 and geological setting), making them especially suitable for dynamic time warping (DTW) since they offer greater continuity and completeness. To compare surface geology with subsurface gamma ray records, surface maps from @mantenSilurianReefsGotland1971 and @calnerSilurianGotlandPart2004a were digitised in QGIS and integrated with literature data.
Gamma-ray logs, the primary data type used, reflect natural radiation from Potassium-40, Uranium-238, and Thorium-232 in surrounding rocks [@ellisWellLoggingEarth2007].
Since spectral gamma data are unavailable for Gotland, interpretations focus on relative changes in log motifs. The logs have a vertical resolution of about 0.15 to 0.3 meters [@ellisWellLoggingEarth2007].
The limited resolution, combined with the inclusion of legacy data, restricts the ability to correlate on a bed-by-bed basis. As such, we will focus on general patterns, inflexion points, and prominent metre-scale peaks and troughs.

One aim of this study is to present a quasi-automated workflow for well-log correlation using the Dynamic Time Warping (DTW) algorithm combined with Barycenter Averaging (DBA). Rather than redeveloping existing methods, this study integrates off-the-shelf R functions into a practical workflow for well-log correlation. The use of established and optimised R packages ensures computational efficiency and reproducibility. In particular, the dtwclust package [@sarda-espinosaTimeseriesClusteringUsing2019] provides a robust implementation of the DBA algorithm, which is multi-threaded by default and allows rapid computation of the regional reference curve, typically within minutes. Intermediate data processing steps, such as Taner filtering and LOWESS regression, were performed using functions from the astrochron package (Meyers, 2019). For readers seeking a detailed technical background on the underlying algorithms, we refer to the comprehensive discussions in @sarda-espinosaTimeseriesClusteringUsing2019 and @meyersCyclostratigraphyProblemAstrochronologic2019. To promote transparency and reproducibility, the full R code implementation is provided in Supplementary Information S3, with an accompanying R Quarto and HTML versions available at https://github.com/stratigraphy/DTW-Gotland, which include step-by-step explanations of each stage of the workflow.

Before the analysis, all gamma-ray logs were normalised to a scale of -1 to 1 to allow for a consistent cross-well comparison and to remove any differences in scaling in values due to the use of different gamma-ray well-logging tools. The well-logs were pre-stretched to a common depth scale, a technique often referred to as placing data in "relative geological time"@sylvesterAutomatedMultiwellStratigraphic2023 or “target depth” in the nomenclature presented by @hayLibraryEarlyCambrian2019. DTW-based studies typically apply this concept to close loops and correct errors after DTW correlations have been conducted [@debruinStratigraphicSurfacesDepositional2007; @lomaskNewToolsSeismic2009; @qayyumHistoricalDevelopmentsWheeler2015; @wuAccurateSeismicFlattening2022; @sylvesterAutomatedMultiwellStratigraphic2023].

Pre-stretching offers a clear advantage, as DTW compares patterns within time-series data and, without accounting for thickness variations, stratigraphically equivalent features may misalign. The pre-stretching was guided by six manually selected tie points corresponding to key stratigraphic features (see Figure 2).  The pre-stretching using the tie points acts as a (soft) constraint on the stratigraphic framework, since subsequent DTW runs within the DBA modelling run can still redraw correlation paths based on signal similarity. In this way, geological expertise is integrated without overriding the algorithm’s capacity for objective, data-driven alignment. The approach used is particularly valuable in intervals where correlation confidence is variable rather than absolute. The well logs were pre-stretched to the average observed thickness between the two tie points in the set of wells.  Logs were stretched to the average thickness observed between tie points. The Altajme and Vike-1 wells were excluded from the average thickness calculation because their upper intervals are affected by a prograding reefal system during the Mulde Event [@biebesheimerAsynchronousD13CcarbD13Corg2021].


Tie point set (1) marks a positive gamma-ray inflexion corresponding to the base of the Silurian [@sopherStructureStratigraphySedimentary2016; @erlstromGeophysicalWellLogmotifs2019; @erlstromBerggrundenPaSudret2022]. Set (2) aligns with a negative inflexion linked to the S2–S3 sequence boundary in the Baltic Basin and roughly coincides with the onset of the Ireviken Event (see Figure 2) @lazauskieneSequenceStratigraphyBaltic2003; [@hartkeDecouplingD13CcarbD13Corg2021; @erlstromBerggrundenPaSudret2022]. Set (3) corresponds to a gamma-ray trough at the base of the Mulde Event (see Figure 2 and SI.2.) [@calnerShorelineDeepBasin2006; @erlstromBerggrundenPaSudret2022]. Despite differing log expressions, this tie point could be identified in both the Altajme and Grötlingbo-1 wells, aided by the observation of the Mulde  δ13Ccarb excursion in both records (see SI.2) [@calnerShorelineDeepBasin2006]. Set (4) is a positive gamma-ray inflexion that marks the approximate termination of the Mulde Event, which again could be identified with the help of the records from the Altajme and the more distal Grötlingbo-1 wells/cores [@calnerShorelineDeepBasin2006]. Set (5) is a minor gamma-ray peak traceable across most wells (see Figure 2). Set (6) is a negative inflexion in the gamma-ray log, which marks the boundary between the Hemse Group and Eke Formation [@erikssonSequenceStratigraphicalModel2008; @erlstromBerggrundenPaSudret2022].
Due to the regional dip and erosion, increasingly thicker intervals of younger Silurian strata are missing toward the northwest of Gotland  (see Geological setting). As a result, one or more stratigraphic tie-points may be absent in that direction. The missing tie points prevent stretching to a common depth scale. In such cases, missing intervals were filled using a median curve derived from the complete well logs.

Once the tie-points were defined and the data were pre-stretched, we applied the Dynamic Time Warping with barycenter Averaging (DBA) algorithm [@petitjeanGlobalAveragingMethod2011; @sarda-espinosaTimeseriesClusteringUsing2019;@inproceedings]. The Dynamic Time Warping (DTW) part of the algorithm was performed using the basic DTW algorithm with L2 normalisation and a symmetric step pattern (symmetric2) [@giorginoComputingVisualizingDynamic2009]. The alignment was computed within a moving window of 200 data points, with distance values square-root transformed before analysis. Backtracking was enabled to reconstruct the optimal warping path, and both open-begin and open-end settings were activated to allow flexible alignment at the start and end of the records. The DBA algorithm iteratively aligns all well-log pairs using Dynamic Time Warping. It computes their average trajectory within the DTW space rather than along the original depth or time domain. Unlike a simple arithmetic mean, which assumes uniform scaling across records, DBA calculates a barycenter, a central curve that minimises the overall DTW distance to all input series [@petitjeanGlobalAveragingMethod2011; @sarda-espinosaTimeseriesClusteringUsing2019; @inproceedings]. This is achieved through repeated cycles of alignment and averaging, during which each log is warped toward the evolving barycenter, and the barycenter is updated to the mean of the aligned sequences.

The DBA process reduces the influence of outlier logs or local anomalies while preserving regionally consistent stratigraphic patterns. The resulting barycentric curve represents an optimised, consensus-based gamma-ray reference profile that captures the most stable and correlateable lithological features across the entire set of well-logs. By averaging in the DTW space, DBA yields a more geologically meaningful composite curve than conventional stacking or depth-normalised averaging, particularly in successions where sedimentation rates and compaction histories vary among wells.

Like with most DTW-based alignment techniques, the DBA process can introduce blocky or spiky artefacts due to its tendency to over-sample flat regions. These artefacts were removed using a Taner bandpass filter, followed by a LOWESS regression to preserve local extremes while removing broader trends [@meyersCyclostratigraphyProblemAstrochronologic2019]. From the resulting smoothed and detrended reference curve, the 150 largest-amplitude peaks were selected as regional correlation points. The number itself is not arbitrary, since it corresponds to the maximum number of distinct, geologically meaningful peaks identifiable in the reference curve.
The DTW algorithm was then applied between the reference curve and each of the thirty-eight (pre-stretched) well logs, allowing the regional tie points to be transposed onto the individual logs. These tie points serve as the basis for the drawing of correlation lines across all wells, supporting a detailed subsurface interpretation.

Load in the data
```{r chunk-90}
#| message: false
#| warning: false
#| echo: true
#written by Michiel Arts michiel.arts@stratigraphy.eu
#Ensure that the right working directories are set to allow one to load the right files!!!
#load the R packages ####
library(ggplot2)
library(astrochron)
library(dtw)
library(plotly)
library(rlist)
library(data.table)
library(WaverideR)
library(dtwclust)
library(ggrepel)
library(dplyr)
library(matrixStats)
library(sf)
library(colorspace)
library(ggspatial)
library(rnaturalearth)
library(DescTools)
library(matrixStats)
library(jsonlite)
library(gh)
library(gert)


all_txt_data <- list()


# Clone the repo to a temp directory

Sys.setenv(GITHUB_PAT = "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")
pat <- Sys.getenv("GITHUB_PAT")




repo_path <- tempfile("DTW-Gotland_")
git_clone("git@github.com:stratigraphy/DTW-Gotland.git", repo_path)

all_txt_data <- list()


# 3. Modify the recursive function to include the Authorization header
list_github_txt_files <- function(api_url, token) {
  # Use an Authorization header for authentication
  response <- httr::GET(
    url = api_url,
    httr::add_headers(
      Authorization = paste("token", token),
      Accept = "application/vnd.github.v3+json"
    )
  )
  
  # Check for HTTP errors (like 403 Forbidden)
  if (httr::http_error(response)) {
    stop(paste("GitHub API Error:", httr::status_code(response), httr::content(response, "text", encoding = "UTF-8")))
  }
  
  # Parse the JSON content
  data <- jsonlite::fromJSON(httr::content(response, "text", encoding = "UTF-8"), flatten = TRUE)
  
  txt_files <- character(0)
  
  for (i in seq_along(data$type)) {
    if (data$type[i] == "file" && grepl("\\.txt$", data$name[i], ignore.case = TRUE)) {
      # The 'download_url' is directly provided by the API response
      txt_files <- c(txt_files, data$download_url[i])
    } else if (data$type[i] == "dir") {
      # The API response already contains the 'url' for the subdirectory
      subdir_url <- data$url[i]
      txt_files <- c(txt_files, list_github_txt_files(subdir_url, token))
    }
  }
  return(txt_files)
}


# Top-level directory API URL
root_api <- "https://api.github.com/repos/stratigraphy/DTW-Gotland/contents/SI_4_logs_used"

# You'll need to load the required libraries
if (!requireNamespace("httr", quietly = TRUE)) install.packages("httr")
if (!requireNamespace("jsonlite", quietly = TRUE)) install.packages("jsonlite")
library(httr)
library(jsonlite)

# Call the function with the root URL and the PAT
txt_urls <- list_github_txt_files(root_api, pat)

#txt_urls[1:5]  # preview first few

# Read each text file into a named list
well_logs_list <- list()

for (file_url in txt_urls) {
  first_line <- tryCatch(readLines(file_url, n = 1), error = function(e) return(NA))
  if (is.na(first_line)) next
  
  has_header <- grepl("[A-Za-z]", first_line)
  
  df <- tryCatch({
    if (has_header) {
      read.table(file_url, header = TRUE, sep = "", stringsAsFactors = FALSE)
    } else {
      df <- read.table(file_url, header = FALSE, sep = "", stringsAsFactors = FALSE)
      colnames(df)[1:2] <- c("DEPTH", "GR")
      df
    }
  }, error = function(e) NULL)
  
  if (!is.null(df)) {
    file_name <- tools::file_path_sans_ext(basename(file_url))
    well_logs_list[[file_name]] <- df
    list_name <- paste0(file_name)
    all_txt_data[[list_name]] <- df
  }
}

# Check results
#sort(names(all_txt_data))

# rename to well-log list
well_logs_list <- all_txt_data

for (file_url in txt_urls) {
  first_line <- tryCatch(readLines(file_url, n = 1), error = function(e) return(NA))
  if (is.na(first_line)) next
  
  has_header <- grepl("[A-Za-z]", first_line)
  
  df <- tryCatch({
    if (has_header) {
      read.table(file_url, header = TRUE, sep = "", stringsAsFactors = FALSE)
    } else {
      df <- read.table(file_url, header = FALSE, sep = "", stringsAsFactors = FALSE)
      colnames(df)[1:2] <- c("DEPTH", "GR")
      df
    }
  }, error = function(e) NULL)
  
  if (!is.null(df)) {
    file_name <- tools::file_path_sans_ext(basename(file_url))
    well_logs_list[[file_name]] <- df
    list_name <- paste0(file_name)
    all_txt_data[[list_name]] <- df
  }
}

# rename to well-log list
well_logs_list <- all_txt_data

#remove the _GR. extension from the file names in the list of well-logs
well_logs_list <- all_txt_data
for (col in 1:length(well_logs_list)) {
  names(well_logs_list)[[col]] <-
    gsub("_GR.*", "", names(well_logs_list)[[col]])
}

well_logs_list <- well_logs_list[order(names(well_logs_list))]
```

Load the d13Ccarb record of the Altajme core

```{r chunk-90.1}
#| message: false
#| warning: false
#| echo: true
#load the d13C record of the Altajme core ####

Altamje_d13C <- read.csv("https://raw.githubusercontent.com/stratigraphy/DTW-Gotland/main/Altamje_d13C.csv")

Altamje_d13C <- demean(Altamje_d13C, genplot = F, verbose = F)
Altamje_d13C[, 2]  <- Altamje_d13C[, 2] - min(Altamje_d13C[, 2])
Altamje_d13C[, 2]  <- Altamje_d13C[, 2] / max(Altamje_d13C[, 2])
Altamje_d13C <- iso(Altamje_d13C,
                    xmax = 324,
                    xmin = 0,
                    genplot = FALSE,verbose = F)
```

Load the well tops which are the initial correlation lines drawn into the correlation using existing stratigraphic knowledge.

```{r chunk-90.2}
#| message: false
#| warning: false
#| echo: true
well_tops_rotated <- read.csv("https://raw.githubusercontent.com/stratigraphy/DTW-Gotland/main/well_tops_rotated.csv")

exclude_wells <- c("Skaggs_1", "Sanda_1", "Rings_1", "Grotlingbo_2")
wells_incl <- well_tops_rotated[!well_tops_rotated$Well %in% exclude_wells, ]
```
Calculate the thickness of the beds in-between the initial correlation lines/points.
```{r chunk-90.3}
#| message: false
#| warning: false
#| echo: true

readjusted_matrix <- wells_incl

readjusted_matrix_means <-
  matrix(
    data = NA,
    nrow = nrow(readjusted_matrix),
    ncol = (ncol(readjusted_matrix) - 4)
  )

# fill the matrix with thickness of the beds
for (i in 4:(ncol(readjusted_matrix) - 1)) {
  a <- (i - 3)
  top <- as.matrix(unlist(readjusted_matrix[i + 1]))
  top[is.na(top)] <- 0
  bottom <- as.matrix(unlist(readjusted_matrix[i]))
  readjusted_matrix_means[, a] <- bottom - top
  
  
}


readjusted_matrix_means <- as.data.frame(readjusted_matrix_means)
readjusted_matrix_means$top <-
  as.matrix(unlist(readjusted_matrix[, (ncol(readjusted_matrix))]))
colnames(readjusted_matrix_means) <-
  colnames(readjusted_matrix[, 4:ncol(readjusted_matrix)])
```

Calculate how much the beds in-between the initial correlation lines/points need to stretched in the pre-stretching.

```{r chunk-90.4}
#| message: false
#| warning: false
#| echo: true

#calculate the strechfactor fot the beds
strech_fact <-
  1 / ((readjusted_matrix_means / matrix(
    rep(
      colMaxs(as.matrix(readjusted_matrix_means[c(2:37),]), na.rm = TRUE),
      each = nrow(readjusted_matrix_means)
    ),
    nrow = nrow(readjusted_matrix_means),
    ncol = ncol(readjusted_matrix_means)
  )))

strech_fact <- as.data.frame(strech_fact)
strech_fact <- cbind(readjusted_matrix[, 3], strech_fact)
colnames(strech_fact) <-
  names(readjusted_matrix[, 3:ncol(readjusted_matrix)])

well_padded <- readjusted_matrix
well_padded <- as.data.frame(as.matrix(well_padded))
well_padded <- well_padded[, 4:ncol(well_padded)]
well_padded <-
  lapply(well_padded, function(well_padded)
    as.numeric(as.character(well_padded)))
well_padded <- as.data.frame(well_padded)
colmaxs <- colMeans(as.matrix(well_padded), na.rm = TRUE)


well_padded$top_surface <-
  well_padded[, ncol(well_padded)] - colmaxs[length(colmaxs)]
base_data <- well_padded[, 1] + 20
well_padded <- cbind(base_data, well_padded)
well_padded <- cbind(strech_fact[, 1], well_padded)
colnames(well_padded)[1] <- c("well")

maxvals <-
  colMeans(as.matrix(readjusted_matrix_means), na.rm = TRUE)
maxvals <- c(20, maxvals)
maxvals <- round((maxvals / 0.1), 0)
maxvals_depth <- maxvals

for (i in ((length(maxvals) - 1):1)) {
  maxvals_depth[i] <- maxvals_depth[i] + maxvals_depth[i + 1]
}
maxvals_depth[length(maxvals_depth) + 1] <- 0
```

Conduct the pre-stretching.

```{r chunk-90.5}
# stretch the data to a common depth scale using the mean thickness
prestreched_data <- list()

for (hln in 1:nrow(well_padded)) {
  norm_log <- matrix(ncol = 3)
  norm_log <- as.data.frame(norm_log[-1, ])
  colnames(norm_log) <- c("norm_depth", "proxy", "depth_old")
  index <- grep(well_padded[hln, 1], names(well_logs_list), ignore.case = TRUE)
  well_1 <- well_logs_list[[index[1]]]

  suppressWarnings(
    suppressMessages(
      capture.output(
        well_1 <- sortNave(well_1, genplot = FALSE, verbose = FALSE),
        file = NULL
      )
    )
  )


  well_1 <- linterp(well_1, 0.1, genplot = F, verbose = F)
  well_1 <- demean(well_1, genplot = F, verbose = F)
  well_1[, 2]  <- well_1[, 2] - min(well_1[, 2])
  well_1[, 2]  <- well_1[, 2] / max(well_1[, 2])
  well_1 <- demean(well_1, genplot = F, verbose = F)
  
for (i in 1:(length(maxvals_depth) - 1)) {
    well_1_sel <- well_1[well_1[, 1] < well_padded[hln, i + 1], ]
    
    well_1_sel <-
      well_1_sel[well_1_sel[, 1] > well_padded[hln, i + 2], ]
    new_depths <-
      seq(from = maxvals_depth[i + 1] + 1,
          to = maxvals_depth[i],
          by = 1)
    
    if (nrow(well_1_sel) == 0  | any(is.na(well_1_sel))) {
      pad_NA <- rep(NA, times = length(new_depths))
      seq_1 <- cbind(new_depths, pad_NA, pad_NA)
      
    } else{
      app <-
        approx(
          x = well_1_sel[, 1],
          y = well_1_sel[, 2],
          method = "linear",
          n = length(new_depths),
          rule = 1,
          f = 0,
          ties = mean,
          na.rm = TRUE
        )
      seq_1 <- cbind(new_depths, app$y, app$x)
    }
    
    colnames(seq_1) <- c("norm_depth", "proxy", "depth_old")
    norm_log <- rbind(norm_log, seq_1)
    
  }
  
  norm_log <- norm_log[order(norm_log[, 1], decreasing = FALSE), ]
  prestreched_data <- list.append(prestreched_data, norm_log)
  
}

#if you want to save or load the data
#saveRDS(prestreched_data, file = "prestreched_data.rds")
#prestreched_data <- readRDS("prestreched_data.rds")

#order the data according to the base of the Silurian
prestreched_data <-
  prestreched_data[order(well_padded[, 3], decreasing = T)]
well_padded_ord <- well_padded[order(well_padded[, 3], decreasing = T),]

prestreched_data <- prestreched_data[c(1:34,37,38,35,36)]
well_padded_ord <- well_padded_ord[c(1:34,37,38,35,36),]

names(prestreched_data) <- well_padded_ord[,1]

#create a new matrix to fill with the pre-stretched data
data <- matrix(data = NA, nrow = nrow(prestreched_data[[1]]))
#prestreched_data
#nrow(prestreched_data[[1]])


#fill the matrix with the pre-stretched data which was also normalised (-1 to 1)
for (i in 1:length(prestreched_data)) {
  data_1 <- prestreched_data[[i]]
  data_1 <- data_1[, c(1, 2)]
  data_1[, 2] <- data_1[, 2] - mean(na.omit(data_1[, 2]))
  data_1 <- data_1[, 2]
  data_1 <- data_1 / (max(na.omit(data_1)) - min(na.omit(data_1)))
  data_1 <- data_1 / sd(na.omit(data_1))
  data_1 <- data_1 - mean(na.omit(data_1))
  data_1 <- data_1 / (max(na.omit(data_1)) - min(na.omit(data_1)))
  data_1 <- data_1 - mean(na.omit(data_1))
  data <- cbind(data, data_1)
}
#remove the first empty column
data <- data[, -c(1)]

#create a median curve###
cent <- rowMedians(as.matrix(data), na.rm = TRUE)

#convert the stretched data to a list
data_ls <- as.list(as.data.frame(data))

#pad NA's with the  values of the centroid
for (i in 1:length(data_ls)) {
  data_ls[[i]][is.na(data_ls[[i]])] <- cent[is.na(data_ls[[i]])]
}


exclude_wells <- c("Skaggs_1",
                   "Sanda_1",
                   "Rings_1",
                   "Grotlingbo_2",
                   "Grotlingbo_1",
                   "Grotlingbo_2_Res")

well_logs_list_2 <- well_logs_list[!names(well_logs_list) %in% exclude_wells]
well_tops_rotated_2 <- well_tops_rotated[!well_tops_rotated$Well %in% exclude_wells,]

names_prestretched <- tolower(names(prestreched_data))
names_well_logs <- tolower(names(well_logs_list_2))

# Match names (lowercase) and get index
matched_idx <- match(names_prestretched, names_well_logs)

# Keep only matched and existing entries
valid_idx <- which(!is.na(matched_idx))
matched_order <- matched_idx[valid_idx]

# Reorder well_logs_list_2 to match prestretched_data
well_logs_list_3 <- well_logs_list_2[matched_order]
#well_tops_rotated_2 <- well_tops_rotated_2[matched_order,]


target_order <- names(well_logs_list_3)
well_tops_wells <- well_tops_rotated_2$Well
match_index <- match(toupper(well_tops_wells), toupper(target_order))
sorting_sequence <- order(match_index)
well_tops_rotated_2 <- well_tops_rotated_2[sorting_sequence, ]

# Optional: assign matching names for clarity
names(well_logs_list_3) <- names(prestreched_data)[valid_idx]

for (i in 1:length(well_logs_list_3)) {
  well_1 <- well_logs_list_3[[i]]
  well_1 <- well_1[well_1[, 1] <= max(prestreched_data[[i]][, 3], na.rm = TRUE), ]
  suppressWarnings(
    suppressMessages(
      capture.output(
        well_1 <- sortNave(well_1, genplot = FALSE, verbose = FALSE),
        file = NULL
      )
    )
  )
  well_1 <- linterp(well_1, genplot = FALSE,verbose = F)
  well_1 <- demean(well_1, genplot = F, verbose = F)
  well_1[, 2]  <- well_1[, 2] - min(well_1[, 2])
  well_1[, 2]  <- well_1[, 2] / max(well_1[, 2])
  well_1 <- demean(well_1, genplot = F, verbose = F)
  well_logs_list_3[[i]] <- well_1
}
```

Plot the well-logs pre and post stretching including the corrrelation lines/points.

```{r chunk-91}
#| message: false
#| warning: false
#| echo: true
#| fig.cap: "Figure 2. The well-logs pre and post stretching. A. The thirty-eight gamma-ray well logs, with the original manual tie points and correlation lines (red lines). Included is the δ13Ccarb curve of the Altajme core and Silurian biogeochemical events identified in this record (Biebesheimer et al., 2021; Hartke et al., 2021).  B. All the gamma-ray logs stretched between the tie-points to a common depth scale. Note that the normalised logs, plotted side by side, are sorted in order of depth to the base of the Silurian."

{
  
  
  layout.matrix <-
    matrix(c(1:2), nrow = 2, ncol = 1)
  graphics::layout(mat = layout.matrix,
                   heights = c(1),
                   # Heights of the two rows
                   widths = c(1)) # Widths of the two columns
  par(mar = c(2, 4, 2, 2))
  
  plot(
    well_logs_list_3[[1]][, c(2)],
    y = well_logs_list_3[[1]][, c(1)],
    type = "l",
    xlim = c(0, length(well_logs_list_3) * 0.75),
    ylim = c(520, 0),xaxt="n",ylab="depth (m)",xlab=""
  )
  
  for (i in 2:length(well_logs_list_3)) {
    lines(x = well_logs_list_3[[i]][, c(2)] + (i * (0.75) - 1),
          y = well_logs_list_3[[i]][, c(1)],
          col = "black")
  }
  
  #add the d13C record of the Altajme core to the plot
  lines(x = c(Altamje_d13C[, 2] + ((
    length(prestreched_data) * 0.75
  ) - 0.5)),
  y = Altamje_d13C[, 1],
  col = "green")
  
  y_vals <- well_tops_rotated_2[,4:ncol(well_tops_rotated_2)]
  x_vals <- y_vals
  y_vals
  
  for (i in 1:ncol(y_vals)) {
    for (j in 1:length(well_logs_list_3)) {
      
      x_val_well <- (well_logs_list_3[[j]][, c(2)] + (j * (0.75) - 1))
      y_val_well <- (well_logs_list_3[[j]][, c(1)])
      val_well <- cbind(x_val_well, y_val_well)
      val_well <- val_well[complete.cases(val_well), ]
      row_nr <- Closest(val_well[, 2], y_vals[j,i], which = TRUE)
      if (!is.na(row_nr[1])){x_vals[j,i] <- val_well[row_nr[1]]}
    }
    lines(x = x_vals[, i], y = y_vals[, i], col = "red")
    
    
  }
  
  
  
  
  
  
  
  # plot the prestreched data
  plot(
    prestreched_data[[1]][, c(2)],
    prestreched_data[[1]][, c(1)]/10,
    type = "l",
    xlim = c(0, length(data_ls) * 0.75),
    ylim = c(4500/10, 0),xaxt="n",xlab="",ylab="Normalised (depth scale)"
  )
  for (i in 2:length(data_ls)) {
    lines(x = prestreched_data[[i]][, c(2)] + (i * (0.75) - 1),
          y = prestreched_data[[i]][, c(1)]/10,
          col = "black")
  }
  # add the formation/tie-points boundaries
  abline(h = maxvals_depth/10, col = "red")
}
```

# RESULTS

The DBA algorithm produced a regional gamma-ray reference curve based on the thirty-eight gamma-ray logs (Figure 3A), which was then denoised and detrended (Figures 3A and B). From the detrended curve, a hundred and fifty data points with the largest deviations from the mean trendline were identified as key tie-points for basin-scale correlation (Figures 3B and C).
Each of the thirty-eight gamma-ray logs was aligned to the reference curve using DTW, enabling the hundred and fifty tie-points to be transposed into individual well logs (see Figure 4). This allowed for the automatic generation of correlation lines between corresponding tie-points (Figure 4A and B). It also allowed the construction of a cross-section along a ~60 km transect from the Sindarve-1 well to the Altajme core/well  (Figure 4B). The correlated transect spans depositional settings from shallowest reefal (Altajme) to the deepest marine environment (Sindarve-1), offering a detailed view of lateral stratigraphic variations within the Silurian succession of Gotland.

Run the DBA algorithm to generate the reference curve. 
```{r chunk-92}
#| message: false
#| warning: false
#| echo: true
# run the DTW with Barycenter averaging ####

dtw_avg <- DBA(
  data_ls,
  centroid = cent,
  max.iter = 2000L,
  delta = 0.0025,
  trace = TRUE,
  norm = "L2",
  normalize = TRUE,
  step.pattern = dtw::symmetric2,
  error.check = TRUE,
  window.size = 200,
  backtrack = TRUE,
  sqrt.dist = TRUE,
  mv.ver = "by-variable"
)
```

Denoise and post-process the DBA  reference curve  and select the 150 tie-points.
```{r chunk-92.1}
#| message: false
#| warning: false
#| echo: true
#Denoise and post-process the DBA results and select the 150 tie-points ####
a <- cbind(prestreched_data[[1]][1], dtw_avg)

a <- taner(
  a,
  flow = 1 / 30,
  fhigh = 1 / (max(a[1]) * 2),
  roll = 10 ^ 20,
  detrend = FALSE,
  demean = FALSE,genplot=FALSE,verbose=FALSE
)


a_nl <- noLow(a, smooth = 0.075,genplot=FALSE,verbose=FALSE)
a_mx <- max_detect(a_nl, pts = 5)
a_mn <- min_detect(a_nl, pts = 5)


a_pks <- rbind(a_mx, a_mn)
a_pks[, 2] <- abs(a_pks[, 2])

a_pks <- a_pks[order(-a_pks[, 2]), ]

n_tiepoints <- 150

tie_points <- matrix(data = NA, ncol = 3, nrow = n_tiepoints)
tie_points <- as.data.frame(tie_points)
min_offset <- 0.25

for (i in 1:n_tiepoints) {
  tie_points[i, ] <- a_pks[1, ]
  a_pks <- a_pks[-c(1), ]
  vals <- abs(a_pks[, 1] - tie_points[i, 1])
  a_pks <- a_pks[vals > min_offset, ]
}
```

Plot the reference curve and its derived correlation points.
```{r chunk-92.2}
#| message: false
#| warning: false
#| echo: true
#| fig.cap: "Figure 3. The reference curve and its derived correlation points A. DBA average curve (black line) and the denoised reference curve (red line), B. Detrended and denoised DBA average reference curve (light blue line) and the hundred and fifty correlation points (purple points), C. DBA average curve (black line), the denoised reference curve (red line) and the hundred correlation points (purple points)."

layout.matrix <-
  matrix(c(1:3), nrow = 3, ncol = 1)
graphics::layout(mat = layout.matrix,
                 heights = c(1),
                 # Heights of the two rows
                 widths = c(1)) # Widths of the two columns
par(mar = c(4, 4, 0.5, 0))

plot(
  cbind(prestreched_data[[1]][1], dtw_avg),
  type = "l",
  xlab = "Normalised depth scale",
  ylab = "Normalised gamma=ray"
)
lines(a, col = "red", lwd = 2)

plot(a_nl,
     type = "l",
     xlab = "Normalised depth scale",
     ylab = "Normalised gamma=ray")

points(a_nl[tie_points[, 1], ],
       col = "blue",
       pch = 19,
       cex = 2)

plot(
  cbind(prestreched_data[[1]][1], dtw_avg),
  type = "l",
  lwd = 2,
  xlab = "Normalised depth scale",
  ylab = "Normalised gamma=ray"
)
lines(a, col = "red", lwd = 2)
points(a[tie_points[, 1], ],
       col = "blue",
       pch = 19,
       cex = 2)

```

Re-correlate the wells to the reference curve using DTW.
```{r chunk-92.3}
#| message: false
#| warning: false
#| echo: true
# re-correlate the wells to the reference curve ####

a_pks <- tie_points
tie_points <- matrix(data = NA, ncol = 1, nrow = n_tiepoints)

for (i  in 1:nrow(tie_points)) {
  row_nr_1 <-
    DescTools::Closest(as.matrix(prestreched_data[[1]][1]), a_pks[i, 1], which = TRUE)
  tie_points[i, 1] <- row_nr_1[1]
}

corr_points <- list()
data_tuned_cor <- list()


for (i in 1:length(data_ls)) {
  
  x <- taner(
    cbind(seq(1:length(data_ls[[i]])), data_ls[[i]]),
    flow = 1 / 30,
    fhigh = 1 / (max(a[1]) * 2),
    roll = 10 ^ 20,
    detrend = FALSE,
    genplot = FALSE,
    verbose = FALSE
  )

  dtw_basic_1 <- dtw_basic(
    x = x[, 2],
    y = a[, 2],
    norm = "L2",
    normalize = TRUE,
    step.pattern = dtw::symmetric2,
    error.check = TRUE,
    window.size = 200,
    backtrack = TRUE,
    sqrt.dist = TRUE,
    mv.ver = "by-variable"#,
    #open.end = TRUE,
    #open.begin = TRUE
  )
  
  
  tie_points_2 <- tie_points
  for (j  in 1:nrow(tie_points)) {
    row_nr_1 <-
      DescTools::Closest(dtw_basic_1[[2]], tie_points[j, 1], which = TRUE)
    tie_points_2[j, 1] <- row_nr_1[1]
  }
  
  vals <- prestreched_data[[i]][2][dtw_basic_1[[2]][tie_points_2], ]
  depths <-
    prestreched_data[[i]][3][dtw_basic_1[[2]][tie_points_2], ]
  corr_pts <- cbind(depths, vals)
  
  time_cor <-
    cbind(prestreched_data[[1]][1][dtw_basic_1[[2]][tie_points_2], ], prestreched_data[[1]][1][dtw_basic_1[[3]][tie_points_2], ])
  
capture.output({
  suppressWarnings(
    suppressMessages({
      time_cor <- sortNave(time_cor[, c(1, 2)], genplot = FALSE, verbose = FALSE)
      time_cor <- sortNave(time_cor[, c(2, 1)], genplot = FALSE, verbose = FALSE)
      time_cor <- sortNave(time_cor[, c(2, 1)], genplot = FALSE, verbose = FALSE)
    })
  )
}, file = NULL)



  data_ls_tuned <-suppressMessages(
  suppressWarnings(
    tune(cbind(prestreched_data[[1]][1], prestreched_data[[i]][2]),
         time_cor,
         genplot = FALSE,verbose=FALSE)))
  
  data_ls_tuned[, 1] <- data_ls_tuned[, 1] / 10
  #plot(data_ls_tuned,type="l")
  #plot(cbind(prestreched_data[[1]][1], prestreched_data[[i]][2]),type="l")
  
  data_tuned_cor <- list.append(data_tuned_cor, data_ls_tuned)
  
  corr_points <- list.append(corr_points, corr_pts)
}
```

Plot the tie-points for between all the wells 
```{r chunk-92.4}
#| message: false
#| warning: false
#| echo: true
#| fig.cap: "Figure 4A.  correlation lines drawn between the correlation points. A. All of the thirty-eight gamma-ray logs with the DBA-derived correlation points and lines. Note that we show the normalised logs, plotted side by side, sorted in order of the depth to the base of the Silurian. The reference well was shifted down by 60 metres."


# plot the tie-points for all the wells ####
colors <- rainbow(n_tiepoints)

layout.matrix <- matrix(1,
                        nrow = 1,
                        ncol = 1,
                        byrow = TRUE)
layout(layout.matrix, heights = c(1), widths = c(1))

par(mar = c(4, 4, 1, 0.5))


plot(
  x = c(-2.2, length(data_tuned_cor) * 1.2),
  y = c(525, 0),
  col = "white",
  xlab = "",
  ylab = "depth (m)",
  xaxt = "n",
  xaxs = "i",
  yaxs = "i",
  ylim = c(520, 0)
)            # Draw empty plot

points(
  y = (a[tie_points, 1] / 10) + prestreched_data[[1]][1, 3],
  x = a[tie_points, 2] - 1 ,
  col = colors,
  pch = 19,
  cex = 0.75
)


lines(a[, 2] - 1, (a[, 1] / 10) + prestreched_data[[1]][1, 3])


for (i in 1:length(prestreched_data)) {
  well_line <- cbind(well_logs_list_3[[i]][1], well_logs_list_3[[i]][2])
  pts <- corr_points[[i]]
  for (j in 1:nrow(pts)) {
    rownr <- DescTools::Closest(well_line[, 1], pts[j, 1], which = TRUE)
    if (!is.na(rownr[1])) {
      pts[j, 2] <- well_line[rownr[1], 2]
    }
  }
  
  corr_points[[i]] <- pts
  
  points(
    y = pts[, 1],
    x = pts[, 2] + (i * 1.2) - 1,
    col = colors,
    pch = 19,
    cex = 0.75
  )
  
}



depth_mat <- matrix(data = NA,
                    nrow = n_tiepoints,
                    ncol = length(data_tuned_cor))
val_mat <- matrix(data = NA,
                  nrow = n_tiepoints,
                  ncol = length(data_tuned_cor))

for (i in 1:length(prestreched_data)) {
  pts <- corr_points[[i]]
  depth_mat[, i] <- pts[, 1]
  val_mat[, i] <- pts[, 2] + (i * 1.2) - 1
}


depth_mat <- cbind((a[tie_points, 1] / 10) + prestreched_data[[1]][1, 3], depth_mat)
val_mat <-  cbind(a[tie_points, 2] - 1 , val_mat)



for (i in 1:nrow(val_mat)) {
  vals <- as.data.frame(cbind(val_mat[i, ], depth_mat[i, ]))
  lines(vals, col = colors[i])
  
}

for (i in 1:length(prestreched_data)) {
  lines(cbind(well_logs_list_3[[i]][2] + (i * 1.2) - 1, well_logs_list_3[[i]][1]))
}
```


Based on the stratigraphic knowledge pick the tie-points that belong to formational  boundaries.

```{r chunk-92.5}
#| message: false
#| warning: false

#pick the formational  boundaries ####
{

# base hogklint
# tracked manually !!!!

#x_vals_base_hog <-  ((seq(1:length(well_logs_list_3)) - 1) * 1.2) - 1


iop <- 2
well_sel <- well_logs_list_3[[iop]]
#plot(well_sel[,2],well_sel[,1],type="l",ylim=c(200,0))

pts <- corr_points[[iop]]

# points(
#   pts[,2],pts[,1],
#   col = colors,
#   pch = 19,
#   cex = 0.75
# )
# abline(h=120)






base_hogklint <- c(
  438, # ref
  418,#1
  418,#2
  401,#3
  402,#4
  390,#5
  397,#6
  400.5,#7
  386,#8
  372.5,#9
  381,#10
  372.5,#11
  367.5,#12
  366.75,#13
  352.5,#14
  350,#15
  350,#16
  342,#17
  336,#18
  332.5,#19
  332.5,#20
  337,#21
  327,#22
  328,#23
  330.5,#24
  321,#25
  309.5,#26
  316.25, #27
  304.5,#28
  321,#29
  315,#30
  316.5,#31
  304,#32
  311.5,#33
  313.5,#34
  258,#35
  251,#36
  293.75,#37
  271.6#38
)

vals_ord <- val_mat
depth_mat_ord <- depth_mat

depth_mat_ord <- depth_mat_ord[order(depth_mat[, 1]), ]
vals_ord <- vals_ord[order(depth_mat[, 1]), ]

vals_ord <- vals_ord[, 1:length(base_hogklint)]
depth_mat_ord <- depth_mat_ord[, 1:length(base_hogklint)]


# plot(a[, 2] - 1, (a[, 1] / 10) + prestreched_data[[1]][1, 3],
#      type="l",ylim=c(425,69))
# 
# points(
#   y = (a[tie_points, 1] / 10) + prestreched_data[[1]][1, 3],
#   x = a[tie_points, 2] - 1 ,
#   col = colors,
#   pch = 19,
#   cex = 0.75
# )
#abline(h=73)


# plot(a[, 2] - 1, (a[, 1] / 10) + prestreched_data[[1]][1, 3],type="l",
#      ylim = c(350, 0))
# 
# points(
#   y = (a[tie_points, 1] / 10) + prestreched_data[[1]][1, 3],
#   x = a[tie_points, 2] - 1 ,
#   col = colors,
#   pch = 19,
#   cex = 0.75
# )
#abline(h=260)

#base Silurian
base_silurian <- DescTools::Closest(depth_mat_ord[, 1], 493, which = TRUE)

base_L_Visby <- DescTools::Closest(depth_mat_ord[, 1], 482.6  , which = TRUE)

#base upper Visby
base_U_visby <- DescTools::Closest(depth_mat_ord[, 1], 447, which = TRUE)

# base hogklint
# tracked manually see above

#base Tofta
base_Tofta <- DescTools::Closest(depth_mat_ord[, 1], 432, which = TRUE)
#base Hangvar
base_Hangvar <- DescTools::Closest(depth_mat_ord[, 1], 425, which = TRUE)

#base Slite
base_Slite <- DescTools::Closest(depth_mat_ord[, 1], 415, which = TRUE)
#base Frojel
base_Frojel <- DescTools::Closest(depth_mat_ord[, 1], 353  , which = TRUE)
#base Klinteberg
base_Klinteberg <- DescTools::Closest(depth_mat_ord[, 1], 339.7 , which = TRUE)

#base Hemse
base_Hemse <- DescTools::Closest(depth_mat_ord[, 1], 314, which = TRUE)
#base Etelheim  #start Linde ?
base_Etelhem <- DescTools::Closest(depth_mat_ord[, 1], 260, which = TRUE)
#base Nar 
base_Nar <- DescTools::Closest(depth_mat_ord[, 1], 217, which = TRUE)
#base EKE (option 2)
base_EKE <- DescTools::Closest(depth_mat_ord[, 1], 135, which = TRUE)
#base Burgsvik
base_Burgsvik <- DescTools::Closest(depth_mat_ord[, 1], 118, which = TRUE)
#base Hamra Sundre
base_Hamra_Sundre <- DescTools::Closest(depth_mat_ord[, 1], 71, which = TRUE)

# plot(well_logs_list_3[[1]][,2],well_logs_list_3[[1]][,1],type="l",ylim=c(400,300))
# abline(h=307.5)
#depth_mat_ord[,1]

readjusted_matrix_ord <- readjusted_matrix
Category <- factor(as.character(readjusted_matrix_ord$Well), levels = c(names(prestreched_data)))
readjusted_matrix_ord <- readjusted_matrix_ord[order(Category), ]

readjusted_matrix_ord <-rbind(readjusted_matrix_ord[1,],readjusted_matrix_ord)
readjusted_matrix_ord[1,] <- NA
readjusted_matrix_ord[1,3] <- c("Ref_curve")


readjusted_matrix_ord$base_silurian <- depth_mat_ord[base_silurian, ]
readjusted_matrix_ord$base_L_visby <- depth_mat_ord[base_L_Visby, ]
readjusted_matrix_ord$base_U_visby <- depth_mat_ord[base_U_visby, ]
readjusted_matrix_ord$base_hogklint <- base_hogklint
readjusted_matrix_ord$base_Tofta <- depth_mat_ord[base_Tofta, ]
readjusted_matrix_ord$base_Hangvar <- depth_mat_ord[base_Hangvar, ]
readjusted_matrix_ord$base_Slite <- depth_mat_ord[base_Slite, ]
readjusted_matrix_ord$base_Frojel <- depth_mat_ord[base_Frojel, ]
readjusted_matrix_ord$base_Klinteberg <- depth_mat_ord[base_Klinteberg, ]
readjusted_matrix_ord$base_Hemse <- depth_mat_ord[base_Hemse, ]
readjusted_matrix_ord$base_Etelhem <- depth_mat_ord[base_Etelhem, ]
readjusted_matrix_ord$base_Nar <- depth_mat_ord[base_Nar, ]
readjusted_matrix_ord$base_EKE <- depth_mat_ord[base_EKE, ]
readjusted_matrix_ord$base_Burgsvik <- depth_mat_ord[base_Burgsvik, ]
readjusted_matrix_ord$base_Hamra_Sundre <- depth_mat_ord[base_Hamra_Sundre, ]

#View(readjusted_matrix_ord)

#str(readjusted_matrix_ord)

#names(well_logs_list_3)[sel_wells-1]

sel_wells <- c(2, 3, 4,12,17,30,33,39)
prestreched_data_2 <- well_logs_list_3[sel_wells-1]
corr_points_2 <- corr_points[sel_wells-1]
readjusted_matrix_ord_2 <- readjusted_matrix_ord[sel_wells, ]


readjusted_matrix_ord_2$distance <- NA
readjusted_matrix_ord_2$distance[1] <- 0

for (i in 2:nrow(readjusted_matrix_ord_2)) {
  readjusted_matrix_ord_2$distance[i] <- sqrt(((readjusted_matrix_ord_2$X[i -
                                                                            1] - readjusted_matrix_ord_2$X[i]) ^ 2
  ) +
    ((readjusted_matrix_ord_2$Y[i -
                                  1] - readjusted_matrix_ord_2$Y[i]) ^ 2
    ))
}

readjusted_matrix_ord_2$distance_sum <- cumsum(readjusted_matrix_ord_2$distance)


}
```

plot all the correlations lines in the transect.

```{r chunk-92.6}
#| message: false
#| warning: false
#| echo: true
#| fig.cap: "Figure 4B.  correlation lines drawn between the correlation points. B. The well-logs along the A’-A’’ transect and their DBA-derived correlation points and lines. The X-axis is kilometres along the transect. The normalised logs are plotted with the same amplitude scale, while maintaining their distance along the profile."
#plot all the correlations lines in the transect ####
{
layout.matrix <- matrix(1,
                        nrow = 1,
                        ncol = 1,
                        byrow = TRUE)
layout(layout.matrix, heights = c(1), # Heights of the two rows
       widths = c(1))

par(mar = c(4, 4, 1, 0.5))


plot(
  x = c(-1000, max(readjusted_matrix_ord_2$distance_sum) * 1.1),
  y = c(525, 0),
  col = "white",
  xlab = "m along transect",
  ylab = "depth (m)",
  yaxs = "i",
  ylim = c(520, 0)
)            # Draw empty plot



comp_fact <- 4000

for (i in 1:length(prestreched_data_2)) {
  pts <- corr_points_2[[i]]
  points(
    y = pts[, 1],
    x = pts[, 2] * comp_fact + readjusted_matrix_ord_2$distance_sum[i],
    col = colors,
    pch = 19
  )
  
}

depth_mat_2 <- matrix(data = NA,
                      nrow = n_tiepoints,
                      ncol = length(data_tuned_cor))
val_mat_2 <- matrix(data = NA,
                    nrow = n_tiepoints,
                    ncol = length(data_tuned_cor))

for (i in 1:length(prestreched_data_2)) {
  pts <- corr_points_2[[i]]
  depth_mat_2[, i] <- pts[, 1]
  val_mat_2[, i] <- pts[, 2] * comp_fact + readjusted_matrix_ord_2$distance_sum[i]
}


for (i in 1:nrow(val_mat_2)) {
  #i <-35
  vals <- as.data.frame(cbind(val_mat_2[i, ], depth_mat_2[i, ]))
  lines(vals, col = colors[i])
  
}

for (i in 1:length(prestreched_data_2)) {
  lines(
    cbind(
      prestreched_data_2[[i]][2] * comp_fact + readjusted_matrix_ord_2$distance_sum[i],
      prestreched_data_2[[i]][1]
    )
  )
}
}
```

Plot the geological maps with the wells in the transect

```{r chunk-92.7}
#| message: false
#| warning: false
#| echo: true
#| fig.cap: "Figure 4C. Regional map with the  location of the A’-A’’ transect in Figure 4B"


#plot the formations as polygons #####
library(ggplot2)
library(sf)
library(ggrepel)
library(ggspatial)
library(dplyr)

#------------------------------------------
# Define wells in the intended plotting order
#------------------------------------------
include_wells <- names(prestreched_data_2)

# Subset and reorder wells
well_tops_rotated_4 <- well_tops_rotated_3[
  well_tops_rotated_3$Well %in% include_wells, ]

# Force wells to follow intended order
well_tops_rotated_4$Well <- factor(well_tops_rotated_4$Well, levels = include_wells)
well_tops_rotated_4 <- well_tops_rotated_4[order(well_tops_rotated_4$Well), ]

#------------------------------------------
# Create a single LINESTRING connecting wells in order
#------------------------------------------
coords <- as.matrix(well_tops_rotated_4[, c("X", "Y")])
linesf <- st_sf(
  geometry = st_sfc(st_linestring(coords)),
  crs = st_crs(shapename)
)

#------------------------------------------
# Plot map with formations and geoline
#------------------------------------------
ggplot() +
  geom_sf(data = shapename) +

  # formations (example colors preserved)
  geom_sf(data = Visby,      fill = rgb(195, 121, 170, maxColorValue = 255)) +
  geom_sf(data = Hogklint,   fill = rgb(63, 100, 168,  maxColorValue = 255)) +
  geom_sf(data = Tofta,      fill = rgb(71, 165, 201,  maxColorValue = 255)) +
  geom_sf(data = Hangvar,    fill = "#076766ff") +
  geom_sf(data = Slite,      fill = "#1d9b38ff") +
  geom_sf(data = Frojel,     fill = "#999999ff") +
  geom_sf(data = Halla,      fill = "#976818ff") +
  geom_sf(data = L_Hemse,    fill = "#976818ff") +
  geom_sf(data = Etelheim,   fill = "#8f8d54ff") +
  geom_sf(data = Klinteberg, fill = "#ccde92ff") +
  geom_sf(data = Nar,        fill = "#cb9807ff") +
  geom_sf(data = Eke,        fill = "#f4981dff") +
  geom_sf(data = Brugsvik,   fill = "#f1e513ff") +
  geom_sf(data = Hamra,      fill = "#fdcc68ff") +

  #------------------------------------------
  # Add geoline and well labels
  #------------------------------------------
  geom_sf(data = linesf, linewidth = 0.5, color = "black") +
  geom_point(
    data = well_tops_rotated_4,
    aes(x = X, y = Y),
    size = 1,
    color = "black"
  ) +
  geom_label_repel(
    data = well_tops_rotated_4,
    aes(x = X, y = Y, label = Well),
    box.padding   = 0.2,
    point.padding = 0.2,
    size = 1.8,
    segment.color = 'red',
    segment.size  = 0.1,
    segment.alpha = 1,
    max.overlaps  = 50
  ) +

  #------------------------------------------
  # Scale bar, north arrow, coordinate system
  #------------------------------------------
  annotation_scale(location = "tl") +
  annotation_north_arrow(
    location = "br",
    which_north = "true",
    style = north_arrow_minimal()
  ) +
  coord_sf(default_crs = sf::st_crs(2400), clip = "off") +

  #------------------------------------------
  # Styling
  #------------------------------------------
  theme_minimal() +
  theme(
    panel.grid.major = element_line(color = "gray85", size = 0.2),
    panel.background = element_rect(fill = "white", color = NA)
  )



```

# DISCUSSION

## On the use of the DBA-based workflow for well-log correlations

This study introduces a comprehensive and reproducible workflow for DTW/DBA-based well-log correlation, implemented in the R programming language (see S.I.3). It advances existing DTW based approaches by combing two key innovations: (1), the incorporation of relative stratigraphic depth (re)scaling before DTW alignment, and (2) the iterative construction of a (regional) reference curve using Dynamic Time Warping with Barycenter Averaging (DBA).
The (re)scaling step, which integrates geological expertise directly into the model, ensures that stratigraphic features known to correlate are aligned, even when they differ between well logs. Pre-stretching enhances the consistency of feature matching, improving both correlation accuracy and geological coherence. Correlation quality was assessed based on the continuity of characteristic log motifs and the preservation of stratigraphic relationships documented in the literature.

A total of six tie points were selected to achieve an optimal balance between geological guidance and algorithmic flexibility: fewer points led to correlations inconsistent with the established regional framework, whereas additional tie points risked over-constraining the DTW alignment and introducing interpretative bias. This limited set provided sufficient structure to maintain geological coherence without imposing excessive manual control, guiding the DBA algorithm in constructing a representative reference curve for the regional stratigraphy.

The manually defined tie points used to stretch the data in between the tie points acted as soft constraints rather than fixed anchors, providing broad stratigraphic guidance since the implemented workflow allowed DTW runs within the DBA modelling to redraw correlation paths based on signal similarity, thereby maintaining a balance between geological interpretation and objective, data-driven alignment. This approach is particularly effective in intervals where the confidence in the tie-points is uncertain rather than absolute.


By incorporating the DBA algorithm into the workflow, we overcame a key limitation of relying solely on DTW for stratigraphic correlation. Standard DTW runs often produce correlation paths that diverge and fail to realign when traced through a network of wells [@sylvesterAutomatedMultiwellStratigraphic2023].
A common workaround involves correlating all wells to a single reference log [@wuIncrementalCorrelationMultiple2018; @hayLibraryEarlyCambrian2019;@hagenDynamicTimeWarping2020; @hagenAlgorithmguidedEdiacaranGlobal2024], which can introduce systematic bias since any inaccuracies in the reference are propagated throughout the correlation framework. Using DBA to generate the reference curve is beneficial since the algorithm provides a data-driven solution by iteratively averaging multiple well logs to construct a regional reference curve that captures shared stratigraphic patterns while suppressing local noise and measurement errors. As more records contribute to the averaged reference, the alignment improves progressively, producing a more geologically representative and internally consistent correlation framework. This collective alignment approach reduces the influence of local anomalies and enhances the robustness of the final reference curve-based correlation framework.

Still, the workflow is not optimal since the underlying DTW algorithm, as used and implemented in the dtwclust package [@sarda-espinosaTimeseriesClusteringUsing2019] was originally designed for time-series clustering rather than stratigraphic data. As a result, it lacks some of the geological refinements such as explicit controls on temporal overlap and relative accumulation rate [@hayLibraryEarlyCambrian2019; @hagenDynamicTimeWarping2020; @hagenAlgorithmguidedEdiacaranGlobal2024; @hagenAlignUserFriendlyApp2024]. Future developments that integrate these stratigraphic constraints directly into the DTW algorithm could further enhance the accuracy, interpretability, and geological realism of DBA-based correlation frameworks.

It should be emphasised that the successful generation of a regional reference curve using the DBA algorithm was possible by the relatively high degree of similarity among the well logs, reflecting the basin's “layer cake” stratigraphy. Nonetheless, careful pre-processing by means of the introduction of the tie-points was still essential, given the range of depositional environments represented in the dataset, from lagoonal and reefal facies to deeper basinal settings[@samtlebenDevelopmentFaciesOisotopes2000; @jorgensen3DGeologicalModel2018; @biebesheimerAsynchronousD13CcarbD13Corg2021; @hartkeDecouplingD13CcarbD13Corg2021; @erlstromBerggrundenPaSudret2022].Although effective in this study, the use of a regional reference curve has its limitations, as such other DTW-based methods may be more appropriate in basins with significant lateral variability, such as those with meander belts, large prograding clinoforms, or turbidite deposits  [@sylvesterAutomatedMultiwellStratigraphic2023; @nieminskiTurbiditeCorrelationPaleoseismology2024].

The correlation lines in this study show strong geological coherence, but some imperfections remain. For example, the upper bundle of correlation lines between 0 and 140 m in the Sindarve-1 well converges into a single point at the Ostris-1 well (see Figure 4). The convergence of correlation lines does not accurately reflect the geology of Gotland, which has a dip of (0.2-0.4) degrees towards the South (East), so near-surface correlation lines should end at the surface [@dahlqvistGeochemicalVariationsMidSilurian2012; @erlstromBerggrundenPaSudret2022].

In summary, the combined pre-stretching and DBA-based reference curve workflow provides a rapid, robust approach for generating geologically consistent correlation lines across a basin. This study underscores the value of integrating independent stratigraphic information into DTW-based correlations, effectively merging traditional stratigraphic expertise with modern, data-driven techniques. Nevertheless, the resulting correlations should always be evaluated against established geological knowledge and adjusted where necessary to ensure an accurate and coherent interpretation of the basin’s stratigraphy.

## Subsurface stratigraphy and correlations in Gotland

The DBA-derived correlation lines enabled the subdivision of Gotland's subsurface succession into fifteen units (see Figure 5), further refining the ten subdivisions previously proposed by @erlstromBerggrundenPaSudret2022 for Gotland's subsurface. The fifteen intervals are correlated to previously established surface and shallow subsurface units on Gotland [@calnerSilurianGotlandPart2004a; @calnerShorelineDeepBasin2006; @erikssonSequenceStratigraphicalModel2008; @biebesheimerAsynchronousD13CcarbD13Corg2021; @hartkeDecouplingD13CcarbD13Corg2021; @erlstromBerggrundenPaSudret2022; @stolfusExpansionReducingMarine2023]. Unit names reference surface equivalent formations for convenience but do not imply formal naming or redefinition of the subsurface stratigraphy. Some uncertainty remains, especially for deeper units such as the Fröjel Formation and older units, which lack explicit surface correlations in the studied boreholes. Consequently, the stratigraphic naming convention used in this study should be viewed as tentative.  

Plot the subsurface stratigraphy and along the transect
```{r chunk-92.8}
#| message: false
#| warning: false
#| echo: true
#| fig.cap: "Figure 5A. Gotland's subsurface succession and its correlation.  Correlation of units along the transect A’-A’’. The normalised logs are plotted with the same amplitude scale at the corresponding distance along the profile. The location of the transect is shown in the bottom right of the figure. For the locations of wells, see figure 1. The terminations of the boundaries are based on the geological maps of Gotland (Manten, 1971; Calner et al., 2004a).  Grey dotted lines with question marks indicate uncertainty in the location of the boundaries of the different units. The red dotted line marks the correlation of a small gamma-ray peak, indicating the onset of a minor rise in the δ¹³Ccarb curve, associated with the Ireviken Event."
#plot the formations as polygons #####

{
layout.matrix <- matrix(1,
                        nrow = 1,
                        ncol = 1,
                        byrow = TRUE)
layout(layout.matrix, heights = c(1), # Heights of the two rows
       widths = c(1))

par(mar = c(4, 4, 1, 0.5))


plot(
  x = c(-10000, max(readjusted_matrix_ord_2$distance_sum) * 1.1),
  y = c(525, 0),
  col = "white",
  xlab = "m along transect",
  ylab = "depth (m)",
  ylim = c(520, 0)
)            # Draw empty plot


comp_fact <- 4000

for (i in 1:length(prestreched_data_2)) {
  lines(
    cbind(
      prestreched_data_2[[i]][2] * comp_fact + readjusted_matrix_ord_2$distance_sum[i],
      prestreched_data_2[[i]][1]
    )
  )
  
  
}

depth_mat_sel <- matrix(data = NA, nrow = 8, ncol = 21)
val_mat_sel <- matrix(data = NA, nrow = 8, ncol = 21)

#readjusted_matrix_ord_2
names(readjusted_matrix_ord_2)

for (i in 1:8) {
  dt <-  as.data.frame(prestreched_data_2[[i]])
  dt <- na.omit(dt)
  x_vals <- as.data.frame(dt[, 2])
  y_vals <- as.data.frame(dt[, 1])
  for (j in 4:24) {
    if (!is.na(readjusted_matrix_ord_2[i, j])) {
      row_nr <- DescTools::Closest(readjusted_matrix_ord_2[i, j], y_vals, which = TRUE)
      val_mat_sel[i, j - 3] <- x_vals[row_nr[1], ]
      depth_mat_sel[i, j - 3] <- y_vals[row_nr[1], ]
      y_vals[row_nr[1], ]
      
    }
  }
}


depth_mat_sel <- depth_mat_sel[, c(7:ncol(depth_mat_sel))]
val_mat_sel <- val_mat_sel[, c(7:ncol(val_mat_sel))]
val_mat_sel <- val_mat_sel * comp_fact + readjusted_matrix_ord_2$distance_sum



Altajme_streched <- na.omit(
  cbind(
    well_logs_list_3[[38]][2] * comp_fact + readjusted_matrix_ord_2$distance_sum[8],
    well_logs_list_3[[38]][1]
  )
)


val_mat_sel <- val_mat_sel[, order(depth_mat_sel[1, ], decreasing = TRUE)]
depth_mat_sel <- depth_mat_sel[, order(depth_mat_sel[1, ], decreasing =
                                         TRUE)]

depth_mat_sel[3, 15] <-47
depth_mat_sel[8, 9] <- 130
depth_mat_sel[5, 14] <- 0 
depth_mat_sel[8, 10] <- 0

Altajme_streched_sel_L_SIL <- Altajme_streched[Altajme_streched[, 2] < depth_mat_sel[8, 1], ]
Altajme_streched_sel_L_SIL <- Altajme_streched_sel_L_SIL[Altajme_streched_sel_L_SIL[, 2] >
                                                           depth_mat_sel[8, 2], ]


Altajme_streched_sel_l_visby <- Altajme_streched[Altajme_streched[, 2] <
                                                   depth_mat_sel[8, 2], ]
Altajme_streched_sel_l_visby <- Altajme_streched_sel_l_visby[Altajme_streched_sel_l_visby[, 2] >
                                                               depth_mat_sel[8, 3], ]


Altajme_streched_sel_u_visby <- Altajme_streched[Altajme_streched[, 2] <
                                                   depth_mat_sel[8, 3], ]
Altajme_streched_sel_u_visby <- Altajme_streched_sel_u_visby[Altajme_streched_sel_u_visby[, 2] >
                                                               depth_mat_sel[8, 4], ]

Altajme_streched_sel_Hogklint <- Altajme_streched[Altajme_streched[, 2] <
                                                    depth_mat_sel[8, 4], ]
Altajme_streched_sel_Hogklint <- Altajme_streched_sel_Hogklint[Altajme_streched_sel_Hogklint[, 2] >
                                                                 depth_mat_sel[8, 5], ]




Altajme_streched_sel_Tofta <- Altajme_streched[Altajme_streched[, 2] < depth_mat_sel[8, 5], ]
Altajme_streched_sel_Tofta <- Altajme_streched_sel_Tofta[Altajme_streched_sel_Tofta[, 2] >
                                                           depth_mat_sel[8, 6], ]

Altajme_streched_sel_Hangvar <- Altajme_streched[Altajme_streched[, 2] <
                                                   depth_mat_sel[8, 6], ]
Altajme_streched_sel_Hangvar <- Altajme_streched_sel_Hangvar[Altajme_streched_sel_Hangvar[, 2] >
                                                               depth_mat_sel[8, 7], ]

Altajme_streched_sel_Slite <- Altajme_streched[Altajme_streched[, 2] < depth_mat_sel[8, 7], ]
Altajme_streched_sel_Slite <- Altajme_streched_sel_Slite[Altajme_streched_sel_Slite[, 2] >
                                                           depth_mat_sel[8, 8], ]

Altajme_streched_sel_Mulde_1 <- Altajme_streched[Altajme_streched[, 2] <
                                                   depth_mat_sel[8, 8], ]
Altajme_streched_sel_Mulde_1 <- Altajme_streched_sel_Mulde_1[Altajme_streched_sel_Mulde_1[, 2] >
                                                               depth_mat_sel[8, 9], ]

Altajme_streched_sel_Mulde_2 <- Altajme_streched[Altajme_streched[, 2] <
                                                   depth_mat_sel[8, 9], ]
Altajme_streched_sel_Mulde_2 <- Altajme_streched_sel_Mulde_2[Altajme_streched_sel_Mulde_2[, 2] >
                                                               depth_mat_sel[8, 10], ]

colnames(Altajme_streched_sel_L_SIL) <- c("A", "B")
colnames(Altajme_streched_sel_l_visby) <- c("A", "B")
colnames(Altajme_streched_sel_u_visby) <- c("A", "B")
colnames(Altajme_streched_sel_Hogklint) <- c("A", "B")
colnames(Altajme_streched_sel_Tofta) <- c("A", "B")
colnames(Altajme_streched_sel_Hangvar) <- c("A", "B")
colnames(Altajme_streched_sel_Slite) <- c("A", "B")
colnames(Altajme_streched_sel_Mulde_1) <- c("A", "B")
colnames(Altajme_streched_sel_Mulde_2) <- c("A", "B")

bottom_Sil <- cbind(c(-5000, val_mat_sel[, 1]), c(depth_mat_sel[1, 1], depth_mat_sel[, 1]))
colnames(bottom_Sil) <- c("A", "B")
bottom_L_visby <- cbind(c(-5000, val_mat_sel[, 2]), c(depth_mat_sel[1, 2], depth_mat_sel[, 2]))
colnames(bottom_L_visby) <- c("A", "B")
bottom_u_visby <- cbind(c(-5000, val_mat_sel[, 3]), c(depth_mat_sel[1, 3], depth_mat_sel[, 3]))
colnames(bottom_u_visby) <- c("A", "B")
top_u_visby <- cbind(c(-5000, val_mat_sel[, 4]), c(depth_mat_sel[1, 4], depth_mat_sel[, 4]))
colnames(top_u_visby) <- c("A", "B")
top_Hogklint <- cbind(c(-5000, val_mat_sel[, 5]), c(depth_mat_sel[1, 5], depth_mat_sel[, 5]))
colnames(top_Hogklint) <- c("A", "B")
top_Tofta <- cbind(c(-5000, val_mat_sel[, 6]), c(depth_mat_sel[1, 6], depth_mat_sel[, 6]))
colnames(top_Tofta) <- c("A", "B")
top_Hangvar <- cbind(c(-5000, val_mat_sel[, 7]), c(depth_mat_sel[1, 7], depth_mat_sel[, 7]))
colnames(top_Hangvar) <- c("A", "B")
top_Slite <- cbind(c(-5000, val_mat_sel[, 8]), c(depth_mat_sel[1, 8], depth_mat_sel[, 8]))
colnames(top_Slite) <- c("A", "B")
top_Mulde_1 <- cbind(c(-5000, val_mat_sel[, 9]), c(depth_mat_sel[1, 9], depth_mat_sel[, 9]))
colnames(top_Mulde_1) <- c("A", "B")
top_Mulde_2 <- cbind(c(-5000, val_mat_sel[, 10]), c(depth_mat_sel[1, 10], depth_mat_sel[, 10]))
colnames(top_Mulde_2) <- c("A", "B")

top_Hemse <- cbind(c(-5000, val_mat_sel[, 11]), c(depth_mat_sel[1, 11], depth_mat_sel[, 11]))
colnames(top_Hemse) <- c("A", "B")
base_Etelheim_2 <- cbind(c(-5000, val_mat_sel[, 12]), c(depth_mat_sel[1, 12], depth_mat_sel[, 12]))
colnames(base_Etelheim_2) <- c("A", "B")
base_Eke <- cbind(c(-5000, val_mat_sel[, 13]), c(depth_mat_sel[1, 13], depth_mat_sel[, 13]))
colnames(base_Eke) <- c("A", "B")
base_Burgsvik <- cbind(c(-5000, val_mat_sel[, 14]), c(depth_mat_sel[1, 14], depth_mat_sel[, 14]))
colnames(base_Burgsvik) <- c("A", "B")
base_Hamra_Sundre <- cbind(c(-5000, val_mat_sel[, 15]), c(depth_mat_sel[1, 15], depth_mat_sel[, 15]))
colnames(base_Eke) <- c("A", "B")

L_Sil_col <- "#E2A9CD"
L_Visby_col <- "#C279A9"
U_Visby_col <- "#915E81"
Hogklint_col <- "#4065A9"
Tofta_col <- "#49A6CA"
Hangvar_col  <-  "#0C6867"
Slite_col   <- "#1D9A38"
Frojel_col  <- "#999999ff"
Halla_Klinteberg_col  <- "#966919"
L_Hemse_col  <- "#8E8B52"
Etelheim_col  <- "#CDDE94"
Nar_col  <- "#CA970B"
Eke_col  <- "#F49820"
Brugsvik_col <- "#EFE41B"
Hamra_Sundre_col <- "#FCCB68"

L_Sil <- rbind(bottom_Sil, 
               Altajme_streched_sel_L_SIL[rev(order(Altajme_streched_sel_L_SIL[, 2])), ], 
               bottom_L_visby[rev(order(bottom_L_visby[, 1])), ])

polygon(x = L_Sil[, 1],
        y = L_Sil[, 2],
        col = L_Sil_col)

L_Visby <- rbind(bottom_L_visby,
                 Altajme_streched_sel_l_visby[rev(order(Altajme_streched_sel_l_visby[, 2])), ],
                 bottom_u_visby[rev(order(bottom_u_visby[, 1])), ])
polygon(x = L_Visby[, 1],
        y = L_Visby[, 2],
        col = L_Visby_col)

U_Visby <- rbind(bottom_u_visby, Altajme_streched_sel_u_visby[rev(order(Altajme_streched_sel_u_visby[, 2])), ], top_u_visby[rev(order(top_u_visby[, 1])), ])

polygon(x = U_Visby[, 1],
        y = U_Visby[, 2],
        col = U_Visby_col)

Hogklint <- rbind(top_u_visby, Altajme_streched_sel_Hogklint[rev(order(Altajme_streched_sel_Hogklint[, 2])), ], top_Hogklint[rev(order(top_Hogklint[, 1])), ])
polygon(x = Hogklint[, 1],
        y = Hogklint[, 2],
        col = Hogklint_col)

Tofta <- rbind(top_Hogklint, Altajme_streched_sel_Tofta[rev(order(Altajme_streched_sel_Tofta[, 2])), ], top_Tofta[rev(order(top_Tofta[, 1])), ])
polygon(x = Tofta[, 1],
        y = Tofta[, 2],
        col = Tofta_col)

Hangvar <- rbind(top_Tofta, Altajme_streched_sel_Hangvar[rev(order(Altajme_streched_sel_Hangvar[, 2])), ], top_Hangvar[rev(order(top_Hangvar[, 1])), ])
polygon(x = Hangvar[, 1],
        y = Hangvar[, 2],
        col = Hangvar_col)


top_Slite <- top_Slite[1:7, ]

Slite <- rbind(top_Hangvar,
               Altajme_streched_sel_Slite[rev(order(Altajme_streched_sel_Slite[, 2])), ],
               top_Slite[rev(order(top_Slite[, 1])), ])

polygon(x = Slite[, 1],
        y = Slite[, 2],
        col = Slite_col)


Mulde_1 <- rbind(top_Slite, 
                 Altajme_streched_sel_Mulde_1[rev(order(Altajme_streched_sel_Mulde_1[, 2])), ], 
                 top_Mulde_1[rev(order(top_Mulde_1[, 1])), ])
polygon(x = Mulde_1[, 1],
        y = Mulde_1[, 2],
        col = Frojel_col)

top_Mulde_2_sel <- top_Mulde_2[rev(order(top_Mulde_2[, 1])), ]
top_Mulde_2_sel <- top_Mulde_2_sel[2:8, ]

Mulde_2 <- rbind(
  top_Mulde_1,
  Altajme_streched_sel_Mulde_2[rev(order(Altajme_streched_sel_Mulde_2[, 2])), ],
  c(Altajme_streched_sel_Mulde_2[1, 1], 0),
  c(Altajme_streched_sel_Mulde_2[1, 1] - 5000, 0),
  top_Mulde_2_sel,
  c(-5000,top_Mulde_2_sel[nrow(top_Mulde_2_sel),2])
)
polygon(x = Mulde_2[, 1],
        y = Mulde_2[, 2],
        col = Halla_Klinteberg_col)







L_Hemse <- rbind(
  top_Mulde_2[1:8, ],
  c(Altajme_streched_sel_Mulde_2[1, 1] - 5000, 0),
  c(Altajme_streched_sel_Mulde_2[1, 1] - 7250, 0),
  na.omit(top_Hemse[rev(order(top_Hemse[, 1])), ])
)
polygon(x = L_Hemse[, 1],
        y = L_Hemse[, 2],
        col = L_Hemse_col)



top_Hemse_sel <- na.omit(top_Hemse[rev(order(top_Hemse[, 1])), ])

Etelheim <- rbind(
  na.omit(top_Hemse),
  c(Altajme_streched_sel_Mulde_2[1, 1] - 7250, 0),
  c(top_Hemse_sel[1, 1], 0),
  na.omit(base_Etelheim_2[rev(order(base_Etelheim_2[, 1])), ])
)
polygon(x = Etelheim[, 1],
        y = Etelheim[, 2],
        col = Etelheim_col)

base_Eke_sel <- na.omit(base_Eke[rev(order(base_Eke[, 1])), ])

Nar <- rbind(
  na.omit(base_Etelheim_2),
  c(top_Hemse_sel[1, 1], 0),
  c(base_Eke_sel[1, 1] + 500, 0),
  na.omit(base_Eke[rev(order(base_Eke[1:6, 1])), ])
)


polygon(x = Nar[, 1],
        y = Nar[, 2],
        col = Nar_col)

base_Burgsvik[5, 2] <- base_Burgsvik[5, 2]-6
base_Burgsvik[6,2] <- 40

Eke <- rbind(na.omit(base_Eke[c(1:6), ]),
             c(base_Eke_sel[1, 1] + 500, 0),
             c((22 * 1000) + 500, 0),
             na.omit(base_Burgsvik[rev(order(base_Burgsvik[1:6, 1])), ]))



polygon(x = Eke[, 1],
        y = Eke[, 2],
        col = Eke_col)

base_base_Burgsvik_sel <- na.omit(base_Burgsvik[rev(order(base_Burgsvik[, 1])), ])

Burgsvik <- rbind(
  na.omit(base_Burgsvik[1:6, ]),
  c((22 * 1000) + 500, 0),
  c(base_Hamra_Sundre[5, 1], 0),
  na.omit(base_Hamra_Sundre[rev(order(base_Hamra_Sundre[1:4, 1])), ])
)

polygon(x = Burgsvik[, 1],
        y = Burgsvik[, 2],
        col = Brugsvik_col)


Hamra_Sundre <- rbind(na.omit(base_Hamra_Sundre[1:4, ]),
                      c(base_Hamra_Sundre[5, 1], 0),
                      c(-5000, 0))

polygon(x = Hamra_Sundre[, 1],
        y = Hamra_Sundre[, 2],
        col = Hamra_Sundre_col)



for (i in 1:length(prestreched_data_2)) {
  lines(
    cbind(
      prestreched_data_2[[i]][2] * comp_fact + readjusted_matrix_ord_2$distance_sum[i],
      prestreched_data_2[[i]][1]
    )
  )
  
  
}

# add  the d13C record to the plot
Altamje_d13C <- read.csv("https://raw.githubusercontent.com/stratigraphy/DTW-Gotland/main/Altamje_d13C.csv")
Altamje_d13C <- demean(Altamje_d13C, genplot = F, verbose = F)
Altamje_d13C[, 2]  <- Altamje_d13C[, 2] - min(Altamje_d13C[, 2])
Altamje_d13C[, 2]  <- Altamje_d13C[, 2] / max(Altamje_d13C[, 2])
Altamje_d13C <- iso(Altamje_d13C,
                    xmax = 324,
                    xmin = 0,
                    genplot = FALSE,verbose = F)
lines(
  x = (Altamje_d13C[, 2] * 4000) + 62000,
  y = Altamje_d13C[, 1],
  col = "green"
)
}
```


Plot the subsurface stratigraphy in the reference curve (generated by the DBA algorithm as part of the correlation process), St.Sutarve-2018, and Altajme wells.
```{r chunk-92.9}
#| message: false
#| warning: false
#| echo: true
#| fig.cap: "Figure 5B. Gotland's subsurface succession and its correlation. Stratigraphic units and the well-log as expressed in the reference curve (generated by the DBA algorithm as part of the correlation process), St.Sutarve-2018, and Altajme wells. The black dotted horizontal lines indicate stage boundaries where their actual locations remain uncertain. The red dotted line marks the correlation of a small gamma-ray peak, indicating the onset of a minor rise in the δ¹³Ccarb curve, associated with the Ireviken Event. The yellow half-circles mark the two peaks that are superimposed upon the declining trend in the gamma-ray log of the Upper Visby Formation."
#plot the formations as polygons #####
#plot ages  litholog reference and st.Sutarve-2018 and Altajme ######
{
Llandovery_col <- geo_col(name = "Llandovery")
Wenlock_col <- geo_col(name = "Wenlock")
Telychian_col <- geo_col(name = "Telychian")
Sheinwoodian_col <- geo_col(name = "Sheinwoodian")
Homerian_col <- geo_col(name = "Homerian")
Rhuddanian_col <- geo_col(name = "Rhuddanian")
Aeronian_col <- geo_col(name = "Aeronian")
Ludfordian_col <- geo_col(name = "Ludfordian")
Ludlow_col <- geo_col(name = "Ludlow")
Gorstian_col <- geo_col(name = "Gorstian")
Ord_col <- geo_col(name = "Ordovician")


L_Sil_col <- "#E2A9CD"
L_Visby_col <- "#C279A9"
U_Visby_col <- "#915E81"
Hogklint_col <- "#4065A9"
Tofta_col <- "#49A6CA"
Hangvar_col  <-  "#0C6867"
Slite_col   <- "#1D9A38"
Frojel_col  <- "#999999ff"
Halla_Klinteberg_col  <- "#966919"
L_Hemse_col  <- "#8E8B52"
Etelheim_col  <- "#CDDE94"
Nar_col  <- "#CA970B"
Eke_col  <- "#F49820"
Brugsvik_col <- "#EFE41B"
Hamra_Sundre_col <- "#FCCB68"

shift_down <- 60
# plot(
#   y = (a[tie_points, 1] / 10) + shift_down,
#   x = a[tie_points, 2] - 1 ,
#   col = colors,
#   pch = 19,
#   cex = 0.75
# )
# 
# a_sort <- a[tie_points[order(a[tie_points, 1]),],1]/10
# a_sort
# 
# plot(
#   y = c(a[, 1] / 10)+shift_down,
#   x = a[, 2] ,type="l",
#   ylim=c(450,300)
# )
# 
# depth_mat_sel
# 
# readjusted_matrix_ord

ref_base_hogklint <-base_hogklint[1]
#base Silurian


ref_base_silurian <- readjusted_matrix_ord$base_silurian[1]

ref_base_l_Visby <-readjusted_matrix_ord$base_L_visby[1]

#base upper Visby
ref_base_u_Visby <- readjusted_matrix_ord$base_U_visby[1]

#base Tofta
ref_base_Tofta <- readjusted_matrix_ord$base_Tofta[1]

#base Hangvar
ref_base_Hangvar <- readjusted_matrix_ord$base_Hangvar[1] 
#base Slite
ref_base_Slite <- readjusted_matrix_ord$base_Slite[1]
#base Halla # start Mulde
ref_base_Halla <- readjusted_matrix_ord$base_Klinteberg[1]
#base hemse near end Mulde
ref_base_Hemse <- readjusted_matrix_ord$base_Hemse[1]
#base Etelhem 
ref_base_Etelhem <- readjusted_matrix_ord$base_Etelhem[1]
#base Nar 
ref_base_Nar <-readjusted_matrix_ord$base_Nar[1]
#base EKE 
ref_base_EKE <- readjusted_matrix_ord$base_EKE[1]
#base Burgsvik
ref_base_Burgsvik <- readjusted_matrix_ord$base_Burgsvik[1]
#base Hamra Sundre
ref_base_Ham_Sund <- readjusted_matrix_ord$base_Hamra_Sundre[1]
#base Frojel
ref_base_Frojel <- readjusted_matrix_ord$base_Frojel[1]
#base klinteberg
ref_base_Klinteberg <- readjusted_matrix_ord$base_Klinteberg[1]


{
layout.matrix <-
  matrix(c(1:4), nrow = 1, ncol = 4)

layout(layout.matrix,
       heights = c(1),
       widths = c(1,1,1,2))
par(mar = c(4, 4, 4, 0))

ylims <- c(max((a[, 1] / 10))+2.5+shift_down,0)


plot(
  x = c(0, 1),
  y = c(0, max(ylims)),
  col = "white",
  xlab = "",
  ylab = "Normalised depth (m)",
  xaxt = "n",
  xaxs = "i",
  yaxs = "i",
  ylim = ylims,main="Epoch"
) # Draw empty plot

polygon(
  x = c(0, 1, 1, 0),
  y = c(
    ref_base_silurian,
    ref_base_silurian,
    max(ylims),
    max(ylims)
  ),
  col = Ord_col
)



polygon(
  x = c(0, 1, 1, 0),
  y = c(
    ref_base_silurian,
    ref_base_silurian,
    ref_base_l_Visby,
    ref_base_l_Visby
  ),
  col = Aeronian_col
)

text(x=0.5,y=(ref_base_silurian+(ref_base_l_Visby))/2,
     label="L-Sil")

polygon(
  x = c(0, 1, 1, 0),
  y = c(
    ref_base_l_Visby,
    ref_base_l_Visby,
    ref_base_u_Visby,
    ref_base_u_Visby
    
  ),
  col = Llandovery_col
)

text(x=0.5,y=(ref_base_l_Visby+(ref_base_u_Visby))/2,
     label="Llanovery")


polygon(
  x = c(0, 1, 1, 0),
  y = c(
    ref_base_u_Visby,
    ref_base_u_Visby,
    ref_base_Hemse,
    ref_base_Hemse
  ),
  col = Wenlock_col
)

text(x=0.5,y=(ref_base_Hemse+(ref_base_u_Visby))/2,
     label="Wenlock")

polygon(
  x = c(0, 1, 1, 0),
  y = c(
    ref_base_Hemse,
    ref_base_Hemse,
    0,0
  ),
  col = Ludfordian_col
)

text(x=0.5,y=(ref_base_Hemse+(0))/2,
     label="Ludlow")


par(mar = c(4, 0, 4, 0))

plot(
  x = c(0, 1),
  y = c(0, max(ylims)),
  col = "white",
  xlab = "",
  ylab = "depth (m)",
  xaxt = "n",
  xaxs = "i",
  yaxs = "i",
  yaxt="n",
  ylim = ylims,main="Age"
) # Draw empty plot



polygon(
  x = c(0, 1, 1, 0),
  y = c(
    527.5,
    527.5,
    ref_base_silurian,
    ref_base_silurian
  ),
  col = Ord_col
)

polygon(
  x = c(0, 1, 1, 0),
  y = c(
    ref_base_silurian,
    ref_base_silurian,
    ref_base_l_Visby,
    ref_base_l_Visby
  ),
  col = Aeronian_col
)

text(x=0.5,y=(ref_base_silurian+(ref_base_l_Visby))/2,
     label="Aeronian")

polygon(
  x = c(0, 1, 1, 0),
  y = c(
    ref_base_l_Visby,
    ref_base_l_Visby,
    ref_base_u_Visby+1.5,
    ref_base_u_Visby+1.5
    
  ),
  col = Llandovery_col
)

text(x=0.5,y=(ref_base_u_Visby+(ref_base_l_Visby))/2,
     label="Llandovery")

polygon(
  x = c(0, 1, 1, 0),
  y = c(
    ref_base_u_Visby+1.5,
    ref_base_u_Visby+1.5,
    (ref_base_Slite+ref_base_Halla)/2,
    (ref_base_Slite+ref_base_Halla)/2
  ),
  col = Sheinwoodian_col
)

text(x=0.5,y=(ref_base_u_Visby+1.5+(ref_base_Slite+ref_base_Halla)/2)/2,
     label="Sheinwoodian")

polygon(
  x = c(0, 1, 1, 0),
  y = c(
    (ref_base_Slite+ref_base_Halla)/2,
    (ref_base_Slite+ref_base_Halla)/2,
    ref_base_Hemse,
    ref_base_Hemse
  ),
  col = Homerian_col
)


text(x=0.5,y=(ref_base_Hemse+((ref_base_Slite+ref_base_Halla)/2))/2,
     label="Homerian")

polygon(
  x = c(0, 1, 1, 0),
  y = c(
    
    ref_base_Hemse,
    ref_base_Hemse,
    ref_base_Etelhem,
    ref_base_Etelhem
  ),
  col = Gorstian_col
)
text(x=0.5,y=(ref_base_Hemse+ref_base_Etelhem)/2,
     label="Gorstian")


polygon(
  x = c(0, 1, 1, 0),
  y = c(
    ref_base_Etelhem,
    ref_base_Etelhem,
    0,
    0
  ),
  col = Ludfordian_col
)

text(x=0.5,y=(0+ref_base_Etelhem)/2,
     label="Ludfordian")


par(mar = c(4, 0, 4, 0))

plot(
  x = c(0, 1),
  y = c(0, max(ylims)),
  col = "white",
  xlab = "",
  ylab = "depth (m)",
  xaxt = "n",
  xaxs = "i",
  yaxs = "i",
  yaxt="n",
  ylim = ylims,main="Lith. strat"
) # Draw empty plot


polygon(
  x = c(0, 1, 1, 0),
  y = c(
    527.5,
    527.5,
    ref_base_silurian,
    ref_base_silurian
  )
)

text(x=0.5,y=prestreched_data[[1]][1, 3]/3+(525+(ref_base_silurian))/2,label="Ord")


polygon(
  x = c(0, 1, 1, 0),
  y = c(
    ref_base_silurian,
    ref_base_silurian,
    ref_base_l_Visby,
    ref_base_l_Visby
  ))


text(x=0.5,y=(ref_base_silurian+(ref_base_l_Visby))/2,
     label="L-Sil")


polygon(
  x = c(0, 1, 1, 0),
  y = c(
    ref_base_l_Visby,
    ref_base_l_Visby,
    ref_base_u_Visby,
    ref_base_u_Visby
    
  )
)

text(x=0.5,y=(ref_base_u_Visby+(ref_base_l_Visby))/2,
     label="L-Visby")


polygon(
  x = c(0, 1, 1, 0),
  y = c(
    ref_base_u_Visby,
    ref_base_u_Visby,
    ref_base_hogklint,
    ref_base_hogklint
  ),
  col = 
)

text(x=0.5,y=(ref_base_u_Visby+(ref_base_hogklint))/2,
     label="U-Visby")



polygon(
  x = c(0, 1, 1, 0),
  y = c(
    ref_base_hogklint,
    ref_base_hogklint,
    ref_base_Tofta,
    ref_base_Tofta
  ),
  col = 
)

text(x=0.5,y=(ref_base_Tofta+(ref_base_hogklint))/2,
     label="Hogklint")


polygon(
  x = c(0, 1, 1, 0),
  y = c(
    ref_base_Tofta,
    ref_base_Tofta,
    ref_base_Hangvar,
    ref_base_Hangvar
  ),
  col = 
)

text(x=0.5,y=(ref_base_Tofta+(ref_base_Hangvar))/2,
     label="Tofta")



polygon(
  x = c(0, 1, 1, 0),
  y = c(
    ref_base_Hangvar,
    ref_base_Hangvar,
    ref_base_Slite,
    ref_base_Slite
  ),
  col = 
)

text(x=0.5,y=(ref_base_Slite+(ref_base_Hangvar))/2,
     label="Hangvar")


polygon(
  x = c(0, 1, 1, 0),
  y = c(
    ref_base_Slite,
    ref_base_Slite,
    ref_base_Halla,
    ref_base_Halla
  ),
  col = 
)

text(x=0.5,y=(ref_base_Slite+(ref_base_Halla))/2,
     label="Slite")



polygon(
  x = c(0, 1, 1, 0),
  y = c(
    ref_base_Frojel,
    ref_base_Frojel,
    ref_base_Klinteberg,
    ref_base_Klinteberg
  ),
  col = 
)

text(x=0.5,y=(ref_base_Frojel+(ref_base_Klinteberg))/2,
     label="Frojel")


polygon(
  x = c(0, 1, 1, 0),
  y = c(
    ref_base_Klinteberg,
    ref_base_Klinteberg,
    ref_base_Hemse,
    ref_base_Hemse
  ),
  col = 
)

text(x=0.5,y=(ref_base_Klinteberg+(ref_base_Hemse))/2,
     label="Klinteberg Fm /Halla Fm")


polygon(
  x = c(0, 1, 1, 0),
  y = c(
    ref_base_Hemse,
    ref_base_Hemse,
    ref_base_Etelhem,
    ref_base_Etelhem
  ),
  col = 
)

text(x=0.5,y=(ref_base_Hemse+(ref_base_Etelhem))/2,
     label="L-Hemse Marl Fm")


polygon(
  x = c(0, 1, 1, 0),
  y = c(
    ref_base_Etelhem,
    ref_base_Etelhem,
    ref_base_Nar,
    ref_base_Nar
  ),
  col = 
)

text(x=0.5,y=(ref_base_Etelhem+(ref_base_Nar))/2,
     label="Etelhem Fm")


polygon(
  x = c(0, 1, 1, 0),
  y = c(
    ref_base_Nar,
    ref_base_Nar,
    ref_base_EKE,
    ref_base_EKE
  ),
  col = 
)

text(x=0.5,y=(ref_base_Nar+(ref_base_EKE))/2,
     label="Nar Fm")

polygon(
  x = c(0, 1, 1, 0),
  y = c(
    ref_base_EKE,
    ref_base_EKE,
    ref_base_Burgsvik,
    ref_base_Burgsvik
  ),
  col = 
)

text(x=0.5,y=(ref_base_Burgsvik+(ref_base_EKE))/2,
     label="Eke Fm")


polygon(
  x = c(0, 1, 1, 0),
  y = c(
    ref_base_Burgsvik,
    ref_base_Burgsvik,
    ref_base_Ham_Sund,
    ref_base_Ham_Sund
  ),
  col = 
)

text(x=0.5,y=(ref_base_Burgsvik+(ref_base_Ham_Sund))/2,
     label="Burgsvik Fm")


polygon(
  x = c(0, 1, 1, 0),
  y = c(
    ref_base_Ham_Sund,
    ref_base_Ham_Sund,
    0,
    0
  ),
  col = 
)

text(x=0.5,y=(50+(ref_base_Ham_Sund))/2,
     label="Hamra/Sundre Fm")

par(mar = c(4, 0, 4, 4))

plot(a[, 2], (a[, 1] / 10)+shift_down ,xlab="",yaxs = "i",xaxt="n",
     col = "black", lwd = 1,type="l",xlim=c(-1,3.75),ylim=ylims,yaxt="n",xaxs="i",
     ,main="well-log correlation")


polygon(
  x = c(-1,3.75,3.75,2.5,2,0.75,0.25, -1),
  y = c(
    527.5,
    527.5,
    L_Sil[9,2],
    L_Sil[9,2],
    L_Sil[4,2],
    L_Sil[4,2],
    ref_base_silurian,
    ref_base_silurian
  ),col=Ord_col
)

polygon(
  x = c(-1,0.25,0.75,2,2.5,3.75,3.75,2.5,
        2,0.75,0.25, -1),
  y = c(
    ref_base_silurian,
    ref_base_silurian,
    L_Sil[4,2],
    L_Sil[4,2],
    L_Sil[9,2],
    L_Sil[9,2],
    L_Visby[9,2],
    L_Visby[9,2],
    L_Visby[4,2],
    L_Visby[4,2],
    ref_base_l_Visby,
    ref_base_l_Visby
    
  ),col=L_Sil_col)


polygon(
  x = c(-1,0.25,0.75,2,2.5,3.75,3.75,2.5,
        2,0.75,0.25, -1),
  y = c(
    ref_base_l_Visby,
    ref_base_l_Visby,
    L_Visby[4,2],
    L_Visby[4,2],
    L_Visby[9,2],
    L_Visby[9,2],
    U_Visby[9,2],
    U_Visby[9,2],
    U_Visby[4,2],
    U_Visby[4,2],
    ref_base_u_Visby,
    ref_base_u_Visby
    
  ),col=L_Visby_col)


polygon(
  x = c(-1,0.25,0.75,2,2.5,3.75,3.75,2.5,
        2,0.75,0.25, -1),  y = c(
    ref_base_u_Visby,
    ref_base_u_Visby,
    U_Visby[4,2],
    U_Visby[4,2],
    U_Visby[9,2],
    U_Visby[9,2],
    Hogklint[9,2],
    Hogklint[9,2],
    Hogklint[4,2],
    Hogklint[4,2],
    ref_base_hogklint,
    ref_base_hogklint
    
  ),col=U_Visby_col)




polygon(
  x = c(-1,0.25,0.75,2,2.5,3.75,3.75,2.5,
        2,0.75,0.25, -1),  y = c(
    ref_base_hogklint,
    ref_base_hogklint,
    Hogklint[4,2],
    Hogklint[4,2],
    Hogklint[9,2],
    Hogklint[9,2],
    Tofta[9,2],
    Tofta[9,2],
    Tofta[4,2],
    Tofta[4,2],
    ref_base_Tofta,
    ref_base_Tofta
    
  ),col=Hogklint_col)

polygon(
  x = c(-1,0.25,0.75,2,2.5,3.75,3.75,2.5,
        2,0.75,0.25, -1),  y = c(
    ref_base_Tofta,
    ref_base_Tofta,
    Tofta[4,2],
    Tofta[4,2],
    Tofta[9,2],
    Tofta[9,2],
    Hangvar[9,2],
    Hangvar[9,2],
    Hangvar[4,2],
    Hangvar[4,2],
    ref_base_Hangvar,
    ref_base_Hangvar
    
  ),col=Tofta_col)


polygon(
  x = c(-1,0.25,0.75,2,2.5,3.75,3.75,2.5,
        2,0.75,0.25, -1),  y = c(
    ref_base_Hangvar,
    ref_base_Hangvar,
    Hangvar[4,2],
    Hangvar[4,2],
    Hangvar[9,2],
    Hangvar[9,2],
    Slite[9,2],
    Slite[9,2],
    Slite[4,2],
    Slite[4,2],
    ref_base_Slite,
    ref_base_Slite
    
  ),col=Hangvar_col)


polygon(
  x = c(-1,0.25,0.75,2,2.5,3.75,3.75,2.5,
        2,0.75,0.25, -1),  y = c(
    ref_base_Slite,
    ref_base_Slite,
    Slite[4,2],
    Slite[4,2],
    Slite[9,2],
    Slite[9,2],
    Mulde_1[9,2],
    Mulde_1[9,2],
    Mulde_1[4,2],
    Mulde_1[4,2],
    ref_base_Frojel,
    ref_base_Frojel
    
  ),col=Slite_col)

polygon(
  x = c(-1,0.25,0.75,2,2.5,3.75,3.75,2.5,
        2,0.75,0.25, -1),  y = c(
    ref_base_Frojel,
    ref_base_Frojel,
    Mulde_1[4,2],
    Mulde_1[4,2],
    Mulde_1[9,2],
    Mulde_1[9,2],
    Mulde_2[9,2],
    Mulde_2[9,2],
    Mulde_2[4,2],
    Mulde_2[4,2],
    ref_base_Klinteberg,
    ref_base_Klinteberg
    
  ),col=Frojel_col)

polygon(
  x = c(-1,0.25,0.75,2,2.5,3.75,3.75,2.5,
        2,0.75,0.25, -1),  y = c(
    ref_base_Klinteberg,
    ref_base_Klinteberg,
    Mulde_2[4,2],
    Mulde_2[4,2],
    Mulde_2[9,2],
    Mulde_2[9,2],0,
    0,
    L_Hemse[4,2],
    L_Hemse[4,2],
    ref_base_Hemse,
    ref_base_Hemse
    
  ),col=Halla_Klinteberg_col)


polygon(
  x = c(-1,0.25,0.75,2,2.5,2,0.75,0.25, -1),
  y = c(
    ref_base_Hemse,
    ref_base_Hemse,
    L_Hemse[4,2],
    L_Hemse[4,2],
    0,
    Etelheim[4,2],
    Etelheim[4,2],
    ref_base_Etelhem,
    ref_base_Etelhem
    
  ),col=L_Hemse_col)

polygon(
  x = c(-1,0.25,0.75,2,2.5,2,0.75,0.25, -1),
  y = c(
    ref_base_Etelhem,
    ref_base_Etelhem,
    Etelheim[4,2],
    Etelheim[4,2],
    0,
    Nar[4,2]-4,
    Nar[4,2]-4,
    ref_base_Nar,
    ref_base_Nar
    
  ),col=Etelheim_col)


polygon(
  x = c(-1,0.25,0.75,2,2.5,2,0.75,0.25, -1),
  y = c(
    ref_base_Nar,
    ref_base_Nar,
    Nar[4,2]-4,
    Nar[4,2]-4,
    0,
    Eke[4,2],
    Eke[4,2],
    ref_base_EKE,
    ref_base_EKE
    
  ),col=Nar_col)


polygon(
  x = c(-1,0.25,0.75,2,2.5,2,0.75,0.25, -1),
  y = c(
    ref_base_EKE,
    ref_base_EKE,
    Eke[4,2],
    Eke[4,2],
    0,
    Burgsvik[4,2],
    Burgsvik[4,2],
    ref_base_Burgsvik,
    ref_base_Burgsvik
    
  ),col=Eke_col)

polygon(
  x = c(-1,0.25,0.75,2,2.5,2,0.75,0.25, -1),
  y = c(
    ref_base_Burgsvik,
    ref_base_Burgsvik,
    Burgsvik[4,2],
    Burgsvik[4,2],
    0,
    Hamra_Sundre[4,2],
    Hamra_Sundre[4,2],
    ref_base_Ham_Sund,
    ref_base_Ham_Sund
    
  ),col=Brugsvik_col)

polygon(
  x = c(-1,0.25,0.75,2,2.5,2,0.75,0.25, -1),
  y = c(
    ref_base_Ham_Sund,
    ref_base_Ham_Sund,
    Hamra_Sundre[4,2],
    Hamra_Sundre[4,2],
    0,
    0,
    0,
    0,
    0    
  ),col=Hamra_Sundre_col)

lines(a[, 2], (a[, 1] / 10)+shift_down,lwd=1)
lines((prestreched_data_2$StSutarve_2018[,2])+1.5,prestreched_data_2$StSutarve_2018[,1],lwd=1)
lines((prestreched_data_2$Altajme[,2])+3,prestreched_data_2$Altajme[,1],lwd=1)

}
}
```

The stratigraphically lowest and oldest Silurian unit identified in this study is not exposed at the surface. This unit has to date been identified only in the Grötlingbo-1 well/core, based on an integrated biostratigraphic study indicating the presence of a Rhuddanian to Aeronian-aged unit, separated by a gap spanning the late Aeronian to early Telychian [@mannikIntegratedUpperOrdovician2015].The lower Silurian unit is typified by higher gamma-ray values than the overlying Lower Visby Formation. A sharp rise in gamma-ray intensity marks the base of the lower Silurian unit. Variations in thickness and gamma-ray response within this unit create uncertainty about consistently assigning it to a specific stage or biostratigraphic interval across the study area. Further research is needed to clarify its stratigraphic affinity.

The base of the Lower Visby Formation coincides with a transition from the high gamma-ray values of the lower Silurian unit to the stable and moderately high gamma-ray values of the Lower Visby Formation. The top of the Lower Visby is marked by a peak in the gamma-ray log. This peak is preceded by a smaller peak in the gamma-ray log, which marks the onset of a minor rise in the δ¹³Ccarb curve, associated with the Ireviken Event (see Figure 5A). The smaller gamma-ray peak likely represents the onset of a period of enhanced primary productivity before the Ireviken Extinction Event [@vandenbrouckeReconstructingEnvironmentalConditions2013; @hartkeDecouplingD13CcarbD13Corg2021; @stolfusExpansionReducingMarine2023].The smaller gamma-ray peak below the Lower to Upper Visby Formation boundary can be easily traced across the different well logs, confirming its utility for stratigraphic correlation. The base of the Lower Visby Formation coincides with a transition from the high gamma-ray values of the lower Silurian unit to the stable and moderately high gamma-ray values of the Lower Visby Formation. 

The Upper Visby Formation corresponds to an interval of rising δ¹³Ccarb values and a steady decrease in gamma-ray log values (Figure 5). In the well logs spanning the transect between the Sindarve-1 and Vastergade-1 wells, two small but noticeable peaks are observed, superimposed on the declining trend in the gamma-ray log of the Upper Visby Formation (see Figure 5). These two peaks are absent in the shallower part of the basin that spans the Ostris-1, Hemse-1, and Altajme wells. The absence of these peaks suggests that part of the Upper Visby Formation is missing in the shallower parts of the basin, which is consistent with the unconformable nature observed for some of the boundaries between the Upper Visby Formation and the Högklint Formation [@mantenSilurianReefsGotland1971; @jeppssonLatestLlandoveryLatest2006; @cramerApplicationIntegratedHighResolution2009]. The variable gamma-ray response of this boundary necessitated manual tracking of the formation boundary, highlighting a limitation in the process that generated the DBA-based correlation lines.

The Högklint Formation is characterised by low gamma-ray values that increase gradually. In the Altajme Core, this unit is typified by numerous small, positive δ¹³Ccarb peaks (~1‰) that are superimposed on the larger peak. Sadly, the gamma-ray log lacks the resolution to resolve these finer-scale geochemical features.  A distinct positive inflexion in the gamma-ray log marks the boundary with the overlying Tofta Formation. Stable, high δ¹³Ccarb values and low gamma-ray values typify the Tofta Formation. A positive gamma-ray inflexion marks its upper boundary with the Hangvar Formation. 

The Hangvar Formation is characterised by numerous small negative δ¹³Ccarb peaks (~1‰) that are superimposed on a larger declining trend [@hartkeDecouplingD13CcarbD13Corg2021].  Unfortunately, the gamma-ray log lacks the resolution to describe the relationship between the log and these small δ¹³Ccarb peaks. In the Hangvar Formation, gamma-ray values first drop, then rise gradually.  The transition to the Slite Group is marked by a shift toward more stable baseline gamma-ray values. 

Consistently high gamma-ray values characterise the Slite Group and lack internal features suitable for further subdivision. A sharp negative inflexion in the gamma-ray log characterises its boundary with the overlying Fröjel Formation. 

The Fröjel Formation exhibits a distinct gamma-ray trough followed by a sharp positive inflexion at its upper boundary, which coincides with a rise in δ13Ccarb values and the extinction interval of the Mulde Event [@hartkeDecouplingD13CcarbD13Corg2021; @stolfusExpansionReducingMarine2023].


The Halla/Klinteberg formations are characterised by intermediate gamma-ray values forming a broad trough between the lower values of the Fröjel Formation and the higher values of the Slite Group. The Halla/Klinteberg formations lack clear internal markers, which prevents subdivision at the formation level. The Halla/Klinteberg formations correspond to the double δ13Ccarb peak of the Mulde Event [@calnerSilurianGotlandPart2004a; @radzeviciusPristiograptusGraptoloideaUpper2014; @biebesheimerAsynchronousD13CcarbD13Corg2021]. The notably greater thickness of the Halla/Klinteberg formations in the Altajme and Vike-1 wells, compared to more southerly locations, reflects enhanced reef development during the Mulde Event  [@samtlebenDevelopmentFaciesOisotopes2000; @mclaughlinRisePinnacleReefs2019; @biebesheimerAsynchronousD13CcarbD13Corg2021].
TThe significant difference between the Altajme well/core and other records hinders the correlation of the δ13Ccarb peaks into the distal part of the basin. High-resolution δ13Ccarb profiles are therefore needed to better understand the relationship between gamma-ray log patterns and the carbon-isotope signal. Moreover, reefal influence in the Altajme core has altered the gamma-ray expression of the Halla/Klinteberg and possibly the Fröjel formations, making it unrepresentative of the more distal southern wells. Within the broader correlation framework, the gamma-ray motif of the St. Sutarve-2018 well is considered more representative for characterising the Halla/Klinteberg, Fröjel, and younger formations (see Figure 5).

A positive inflexion in the gamma-ray log values defines the boundary between the Klinteberg and the Hemse formations. On the surface, the boundary between the Klinteberg and the Hemse formations is defined by the lithological transition from reefal carbonates to marls. This transition is interpreted as diachronous, depending on the local depositional setting [@flodenSilurianReefalSuccession2001; @calnerCarbonatePlatformEvolution2003; @calnerSilurianGotlandPart2004a].  In the subsurface, the thickness and well-log records of the underlying Halla/Klinteberg Formation do not change much in the transect between the Hemse-1 and Sindarve-1 wells, nor does the gamma-ray signature of the boundary itself change much (see Figure 5).
The Lower Hemse Marl Formation is marked by high and consistent gamma-ray values, with an increased variability at the boundary with the overlying formation (Etelhem formation). The shallower well-logs display an invariant gamma-ray log response (see Figures 4 and 5).  
The Etelhem Formation is typified by high gamma-ray values, punctuated by irregular peaks and drops in the gamma-ray log. Surface studies associate the Linde Event with the lower part of the However, the absence of biostratigraphic and geochemical proxy data for this interval in the subsurface limits the ability to confidently identify the Linde Event. 
A significant gamma-ray drop marks the base of the När Formation, potentially corresponding to the Millklint limestone unit [@calnerSilurianGotlandPart2004a; @jeppssonLatestLlandoveryLatest2006], though its exact stratigraphic position remains uncertain.
The När Formation is generally characterised by stable gamma-ray values, aside from a distinct trough at its base. The Lau Event begins within the Botvide Member of the När Formation [@calnerSilurianGotlandPart2004a]. No specific gamma-ray signature can be tied to the Botvide Member. The top of the När Formation is defined by a sharp negative inflexion in the gamma-ray log, marking the boundary with the overlying limestones of the Eke Formation. 
The Eke Formation consists of algal limestones, exhibits low gamma-ray values, and encompasses the major rise and peak of the δ13Ccarb excursion of the Lau Event [@calnerShorelineDeepBasin2006; @younesFirstContinuousD13C2017; @erlstromBerggrundenPaSudret2022].A sharp increase in gamma-ray values marks the transition to the overlying Burgsvik Formation

The Burgsvik Formation displays alternating low and high gamma-ray values, reflecting an alternation of siltstones and limestones [@calnerShorelineDeepBasin2006; @erikssonSequenceStratigraphicalModel2008; @erlstromBerggrundenPaSudret2022].
The Burgsvik Formation spans the upper part of the δ13Ccarb excursion of the Lau Event [@younesFirstContinuousD13C2017].
A decrease in the gamma-ray values marks the boundary to the overlying Hamra/Sundre formations.
Low gamma-ray values mark the Hamra/Sundre formations. The formations coincide with a return to baseline δ13Ccarb value [@calnerSilurianGotlandPart2004a; @calnerShorelineDeepBasin2006; @erikssonSequenceStratigraphicalModel2008; @erlstromBerggrundenPaSudret2022]. Among the youngest units identified, the Hamra and Sundre formations were encountered in only a limited number of wells, limiting the ability to assess internal gamma-ray variability and making correlations less certain.

# CONCLUSIONS

This study presents a comprehensive, reproducible workflow that integrates well-log data with DTW/DBA-based algorithms to perform stratigraphic correlation. The iterative construction of a regional reference curve using the DBA algorithm enabled consistent alignment across multiple well logs, highlighting the potential of DTW-based methods in improving correlations within relatively uniform successions.
The workflow was applied to a set of well logs spanning the Silurian succession of central and southern Gotland, enabling a semi-automated correlation that subdivided the subsurface into fifteen distinct geological units. Many of the identified subsurface units were successfully tied to their surface equivalents, though the quality of these correlations varied. Notably, the subdivision of the Hemse Group proved challenging due to significant uncertainties in its internal stratigraphy and boundaries.
The analysis effectively captured gamma-ray log responses associated with key biogeochemical events, including the Ireviken, Mulde, and Lau events, providing valuable insights into their subsurface expression and confirming their stratigraphic significance. In contrast, the Linde Event could not be identified in the gamma-ray data, emphasising the need for additional high-resolution δ13Ccarb records to refine its stratigraphic placement and improve interpretations of the surrounding units.

# ACKNOWLEDGMENTS
The FNRS-PDR T.0051.19 grant financially supported Michiel Arts. Anne-Christine Da Silva acknowledges the “Conseil Universitaire de la recherche et la valorisation,”. Rohit Samant has been funded by the Deutsche Forschungsgemeinschaft (VL96/9-1, grant no. 527307807). We want to thank an anonymous reviewer for their comprehensive feedback, which greatly improved this contribution.  Mathias Sinnesael is thanked for his feedback on a preliminary edition of the manuscript. We further acknowledge the Workshop on Machine Learning Approaches for Automating Geological Correlation (November–December 2022), hosted by David De Vleeschouwer and Ewa Burwicz-Galerne at the MARUM Institute, Bremen, where the discussions provided the foundation for the ideas developed in this manuscript.



##### SI 2. Find the base of the Mulde Event and correlate it

plot the study on identifying the base of the Mulde Event
```{r chunk-100}
#| message: false
#| warning: false
#| echo: true
library(lasr)

# Define the exact file path and construct the raw URL
file_path_in_repo <- "SI_4_logs_used/logs_SI_2/GROTLINGBO-1/GROTLINGBO-1_FDC_Sc23427-2851.las"
las_url <- paste0("https://raw.githubusercontent.com/stratigraphy/DTW-Gotland/main/", file_path_in_repo)
temp_file <- tempfile(fileext = ".las")
download.file(url = las_url, destfile = temp_file, mode = "wb")
las <- read.las(temp_file)
GB_1_log <- as.data.frame(las$log$log.1$data)  



file_path_in_repo <- "SI_4_logs_used/logs_SI_2/GRÖTLINGBO-2/Sc23427-2219.las"
las_url <- paste0("https://raw.githubusercontent.com/stratigraphy/DTW-Gotland/main/", file_path_in_repo)
temp_file <- tempfile(fileext = ".las")
download.file(url = las_url, destfile = temp_file, mode = "wb")
las <- read.las(temp_file)
GB_2_log <- cbind(las$log$log.1$data[[1]],las$log$log.1$data[[2]])

# Read and process Kauparve_1_RES
Kauparve_1_RES <- read.csv("https://raw.githubusercontent.com/stratigraphy/DTW-Gotland/main/SI_4_logs_used/logs_SI_2/Kauparve_1_RES.csv")
Kauparve_1_RES <- Kauparve_1_RES[, c(2, 3)]

invisible(capture.output({
  Kauparve_1_RES <- sortNave(Kauparve_1_RES, genplot = FALSE, verbose = FALSE)
}))
Kauparve_1_RES <- Kauparve_1_RES[Kauparve_1_RES[, 1] < 425, ]

# Read and process Grotlingbo_2_Res
Grotlingbo_2_Res <- read.csv("https://raw.githubusercontent.com/stratigraphy/DTW-Gotland/main/SI_4_logs_used/logs_SI_2/Grotlingbo_2_Res_2.csv")
Grotlingbo_2_Res <- Grotlingbo_2_Res[, c(2, 3)]

invisible(capture.output({
  Grotlingbo_2_Res <- sortNave(Grotlingbo_2_Res, genplot = FALSE, verbose = FALSE)
}))
Grotlingbo_2_Res <- Grotlingbo_2_Res[Grotlingbo_2_Res[, 1] < 425, ]

invisible(capture.output({
  Grotlingbo_2_Res <- linterp(Grotlingbo_2_Res, dt = 0.1, genplot = FALSE, verbose = FALSE)
}))

# Read and process Kauparve_1_GR
Kauparve_1_GR <- read.csv(
  "https://raw.githubusercontent.com/stratigraphy/DTW-Gotland/main/SI_4_logs_used/OPAB_Digitized/KAUPARVE_1_GR.TXT",
  sep = "\t"
)
invisible(capture.output({
  Kauparve_1_GR <- sortNave(Kauparve_1_GR, genplot = FALSE, verbose = FALSE)
}))


layout.matrix <-
  matrix(c(1:4), nrow = 1, ncol = 4)

layout(layout.matrix,
       heights = c(1, 1, 1,1),
       widths = c(1, 1, 1,1))

par(mar = c(4, 4, 4, 0.5))

plot(
  Kauparve_1_GR[, 2],
  Kauparve_1_GR[, 1],
  type = "l",
  ylim = c(425, 0),
  main = "Kauparve-1 Gamma-ray",
  ylab = "depth (m)",
  xlab = "Gamma-ray"
)
abline(h = 267, lty = 3, col = "red")
abline(h = 239, lty = 3, col = "red")

plot(
  -log(Kauparve_1_RES[, 2]),
  Kauparve_1_RES[, 1],
  type = "l"
  ,
  ylim = c(425, 0),
  main = "Kauparve-1 Resistivity",
  ylab = "depth (m)",
  xlab = "-log(resistibity)"
)
abline(h = 267, lty = 3, col = "red")
abline(h = 239, lty = 3, col = "red")


plot(
  -log(Grotlingbo_2_Res[, 2]),
  Grotlingbo_2_Res[, 1],
  type = "l"
  ,
  ylim = c(425, 0),
  main = "Grotlingbo-2 Resistivity",
  ylab = "depth (m)",
  xlab = "-log(resistibity)"
)
lines(-log(GB_2_log[,2]),GB_2_log[,1],col="red")

abline(h = 255, lty = 3, col = "red")
abline(h = 227, lty = 3, col = "red")

plot(
  GB_1_log[, 3],
  GB_1_log[, 1],
  type = "l"
  ,log="x",
  ylim = c(425, 0),
  xlim=c(2.65,2.35),
  main = "Grotlingbo-1 Density",
  ylab = "depth (m)",
  xlab = "density (gr/cm^3)")

dens_mean <- mwStats(cbind(GB_1_log[, 1],GB_1_log[, 3]),genplot=F, win=2,verbose = F)

lines(dens_mean[,2],dens_mean[,1],col="green",lwd=2)

abline(h = 255, lty = 3, col = "red")
abline(h = 227, lty = 3, col = "red")

```
